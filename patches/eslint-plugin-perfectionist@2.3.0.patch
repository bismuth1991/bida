diff --git a/dist/index.js b/dist/index.js
index ed77ec6d1d1f9275338d6b91e0bff63ba4d95853..935e98a86a4736c0ed5b9d7f10cd6d2ba2988f64 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -1,3 +1,3 @@
-"use strict";const W=require("node:path"),_=require("@typescript-eslint/utils"),U=require("minimatch"),ue=require("natural-compare-lite"),ce=require("node:module");let j=_.ESLintUtils.RuleCreator(r=>`https://eslint-plugin-perfectionist.azat.io/rules/${r}`),x=(r,l)=>{for(let s=0,t=r.length;s<t;s++){let u=r[s];if(l.group===u||Array.isArray(u)&&typeof l.group=="string"&&u.includes(l.group))return s}return r.length},v=r=>{let[l,s]=r;return s-l},k=r=>r>0;var p=(r=>(r.alphabetical="alphabetical",r["line-length"]="line-length",r.natural="natural",r))(p||{}),d=(r=>(r.desc="desc",r.asc="asc",r))(d||{});let R=r=>{let l,s=u=>{!l&&r.flat().includes(u)&&(l=u)};return{getGroup:()=>l??"unknown",setCustomGroups:(u,n)=>{if(u)for(let[e,a]of Object.entries(u))Array.isArray(a)&&a.some(i=>U.minimatch(n,i,{nocomment:!0}))&&s(e),typeof a=="string"&&U.minimatch(n,a,{nocomment:!0})&&s(e)},defineGroup:s}},O=(r,l,s)=>{var e,a;if((e=l.dependencies)!=null&&e.includes(r.name))return-1;if((a=r.dependencies)!=null&&a.includes(l.name))return 1;let t=s.order==="asc"?1:-1,u,n=i=>s["ignore-case"]?i.toLowerCase():i;return s.type===p.alphabetical?u=(i,o)=>n(i.name).localeCompare(n(o.name)):s.type===p.natural?u=(i,o)=>ue(n(i.name),n(o.name)):u=(i,o)=>{let c=i.size,y=o.size,h=s["max-line-length"];if(h){let f=(g,m)=>g>h&&m.hasMultipleImportDeclarations;f(c,i)&&(c=i.name.length+10),f(y,o)&&(y=o.name.length+10)}return c-y},t*u(r,l)},A=(r,l)=>[...r].sort((s,t)=>O(s,t,l)),de=(r,l)=>{let s=l.getTokenAfter(r,{filter:({value:t,type:u})=>!(u==="Punctuator"&&[",",";"].includes(t)),includeComments:!0});return((s==null?void 0:s.type)==="Block"||(s==null?void 0:s.type)==="Line")&&r.loc.end.line===s.loc.end.line?s:null},pe=(r,l)=>Array.isArray(r)&&r.some(s=>U.minimatch(l.trim(),s,{nocomment:!0}))||typeof r=="string"&&U.minimatch(l.trim(),r,{nocomment:!0})||r===!0,V=(r,l)=>{let[s,t]=l.getTokensBefore(r,{filter:({value:u,type:n})=>!(n==="Punctuator"&&[",",";"].includes(u)),includeComments:!0,count:2});return((t==null?void 0:t.type)==="Block"||(t==null?void 0:t.type)==="Line")&&r.loc.start.line-t.loc.end.line<=1&&(s==null?void 0:s.loc.end.line)!==t.loc.start.line?t:null},M=(r,l,s)=>{var a;let t=r.range.at(0),u=r.range.at(1),n=l.text.slice(t,u);if(_.ASTUtils.isParenthesized(r,l)){let i=l.getTokenBefore(r,_.ASTUtils.isOpeningParenToken),o=l.getTokenAfter(r,_.ASTUtils.isClosingParenToken);t=i.range.at(0),u=o.range.at(1)}let e=V(r,l);if(n.endsWith(";")||n.endsWith(",")){let i=l.getTokensAfter(r,{includeComments:!0,count:2});r.loc.start.line===((a=i.at(1))==null?void 0:a.loc.start.line)&&(u-=1)}return e&&!pe((s==null?void 0:s.partitionComment)??!1,e.value)&&(t=e.range.at(0)),[t,u]},L=(r,l,s,t,u)=>{var a,i;let n=[],e=((a=l.at(0))==null?void 0:a.node.loc.start.line)===((i=l.at(-1))==null?void 0:i.node.loc.end.line);for(let o=0,c=l.length;o<c;o++){let{node:y}=l.at(o);n.push(r.replaceTextRange(M(y,t,u),t.text.slice(...M(s.at(o).node,t,u))));let h=de(s.at(o).node,t);if(h&&!e){let g=[t.getTokenBefore(h).range.at(1),h.range.at(1)];n.push(r.replaceTextRange(g,""));let m=t.getTokenAfter(y);n.push(r.insertTextAfter((m==null?void 0:m.loc.end.line)===y.loc.end.line?m:y,t.text.slice(...g)))}}return n},C=(r={},l)=>Object.assign(l,r),P=(r,l)=>{if(r.length>1)for(let s=1;s<r.length;s++){let t=r.at(s-1),u=r.at(s);t&&u&&l(t,u,s-1)}};const J="sort-svelte-attributes",fe=j({name:J,meta:{type:"suggestion",docs:{description:"enforce sorted Svelte attributes"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},groups:{type:"array"}},additionalProperties:!1}],messages:{unexpectedSvelteAttributesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>W.extname(r.getFilename())!==".svelte"?{}:{SvelteStartTag:l=>{if(l.attributes.length>1){let s=C(r.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1,"custom-groups":{},groups:[]}),t=r.getSourceCode(),u=l.attributes.reduce((n,e)=>{if(e.type==="SvelteSpreadAttribute")return n.push([]),n;let a,{getGroup:i,defineGroup:o,setCustomGroups:c}=R(s.groups);return e.key.type==="SvelteSpecialDirectiveKey"?a=t.text.slice(...e.key.range):typeof e.key.name=="string"?{name:a}=e.key:a=t.text.slice(...e.key.range),c(s["custom-groups"],a),e.type==="SvelteShorthandAttribute"&&(o("svelte-shorthand"),o("shorthand")),(!("value"in e)||Array.isArray(e.value)&&!e.value.at(0))&&o("shorthand"),e.loc.start.line!==e.loc.end.line&&o("multiline"),n.at(-1).push({size:v(e.range),node:e,group:i(),name:a}),n},[[]]);for(let n of u)P(n,(e,a)=>{let i=x(s.groups,e),o=x(s.groups,a);(i>o||i===o&&k(O(e,a,s)))&&r.report({messageId:"unexpectedSvelteAttributesOrder",data:{left:e.name,right:a.name},node:a.node,fix:c=>{let y={};for(let f of n){let g=x(s.groups,f);g in y?y[g]=A([...y[g],f],s):y[g]=[f]}let h=[];for(let f of Object.keys(y).sort())h.push(...A(y[f],s));return L(c,n,h,t)}})})}}}}),X="sort-astro-attributes",ge=j({name:X,meta:{type:"suggestion",docs:{description:"enforce sorted Astro attributes"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},groups:{type:"array"}},additionalProperties:!1}],messages:{unexpectedAstroAttributesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>W.extname(r.getFilename())!==".astro"?{}:{JSXElement:l=>{let{attributes:s}=l.openingElement;if(s.length>1){let t=C(r.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1,"custom-groups":{},groups:[]}),u=r.getSourceCode(),n=s.reduce((e,a)=>{if(a.type==="JSXSpreadAttribute")return e.push([]),e;let i=typeof a.name.name=="string"?a.name.name:u.text.slice(...a.name.range),{getGroup:o,defineGroup:c,setCustomGroups:y}=R(t.groups);return y(t["custom-groups"],i),a.type==="AstroShorthandAttribute"&&(c("astro-shorthand"),c("shorthand")),a.value===null&&c("shorthand"),a.loc.start.line!==a.loc.end.line&&c("multiline"),e.at(-1).push({size:v(a.range),node:a,group:o(),name:i}),e},[[]]);for(let e of n)P(e,(a,i)=>{let o=x(t.groups,a),c=x(t.groups,i);(o>c||o===c&&k(O(a,i,t)))&&r.report({messageId:"unexpectedAstroAttributesOrder",data:{left:a.name,right:i.name},node:i.node,fix:y=>{let h={};for(let g of e){let m=x(t.groups,g);m in h?h[m]=A([...h[m],g],t):h[m]=[g]}let f=[];for(let g of Object.keys(h).sort())f.push(...A(h[g],t));return L(y,e,f,u)}})})}}}});let I=r=>r.replaceAll(/\s\s+/g," ").trim();const K="sort-array-includes",ye=j({name:K,meta:{type:"suggestion",docs:{description:"enforce sorted arrays before include method"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},"spread-last":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedArrayIncludesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>({MemberExpression:l=>{if((l.object.type==="ArrayExpression"||l.object.type==="NewExpression")&&l.property.type==="Identifier"&&l.property.name==="includes"){let s=l.object.type==="ArrayExpression"?l.object.elements:l.object.arguments;if(s.length>1){let t=C(r.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1,"spread-last":!1}),u=r.getSourceCode(),n=s.reduce((e,a)=>(a!==null&&e.at(0).push({name:a.type==="Literal"?`${a.value}`:u.text.slice(...a.range),size:v(a.range),type:a.type,node:a}),e),[[],[]]).flat();P(n,(e,a)=>{let i;t["spread-last"]&&e.node.type==="Literal"&&a.node.type==="SpreadElement"?i=!1:t["spread-last"]&&e.node.type==="SpreadElement"&&a.node.type==="Literal"?i=!0:i=k(O(e,a,t)),i&&r.report({messageId:"unexpectedArrayIncludesOrder",data:{left:I(e.name),right:I(a.name)},node:a.node,fix:o=>{let c=A(n,t);if(t["spread-last"])for(let y=0,h=c.length;y<h;y++)c.at(y).node.type==="SpreadElement"&&c.push(c.splice(y,1).at(0));return L(o,n,c,u)}})})}}}})}),F="sort-vue-attributes",me=j({name:F,meta:{type:"suggestion",docs:{description:"enforce sorted Vue attributes"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},groups:{type:"array",default:[]}},additionalProperties:!1}],messages:{unexpectedVueAttributesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>{if(W.extname(r.getFilename())!==".vue")return{};if(!("defineTemplateBodyVisitor"in r.parserServices))return{};let{defineTemplateBodyVisitor:l}=r.parserServices;return l({VStartTag:s=>{if(s.attributes.length>1){let t=C(r.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1,"custom-groups":{},groups:[]}),u=r.getSourceCode(),n=s.attributes.reduce((e,a)=>{if(a.key.type==="VDirectiveKey"&&a.key.name.rawName==="bind")return e.push([]),e;let i,{getGroup:o,defineGroup:c,setCustomGroups:y}=R(t.groups);return typeof a.key.name=="string"&&a.key.type!=="VDirectiveKey"?i=a.key.rawName:i=u.text.slice(...a.key.range),y(t["custom-groups"],i),a.value===null&&c("shorthand"),a.loc.start.line!==a.loc.end.line&&c("multiline"),e.at(-1).push({size:v(a.range),node:a,group:o(),name:i}),e},[[]]);for(let e of n)P(e,(a,i)=>{let o=x(t.groups,a),c=x(t.groups,i);(o>c||o===c&&k(O(a,i,t)))&&r.report({messageId:"unexpectedVueAttributesOrder",data:{left:a.name,right:i.name},node:i.node,fix:y=>{let h={};for(let g of e){let m=x(t.groups,g);m in h?h[m]=A([...h[m],g],t):h[m]=[g]}let f=[];for(let g of Object.keys(h).sort())f.push(...A(h[g],t));return L(y,e,f,u)}})})}}})}}),H="sort-named-exports",he=j({name:H,meta:{type:"suggestion",docs:{description:"enforce sorted named exports"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedNamedExportsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>({ExportNamedDeclaration:l=>{if(l.specifiers.length>1){let s=C(r.options.at(0),{type:p.alphabetical,"ignore-case":!1,order:d.asc}),t=r.getSourceCode(),u=l.specifiers.map(n=>({size:v(n.range),name:n.local.name,node:n}));P(u,(n,e)=>{k(O(n,e,s))&&r.report({messageId:"unexpectedNamedExportsOrder",data:{left:n.name,right:e.name},node:e.node,fix:a=>L(a,u,A(u,s),t)})})}}})}),Q="sort-named-imports",be=j({name:Q,meta:{type:"suggestion",docs:{description:"enforce sorted named imports"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},"ignore-alias":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedNamedImportsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>({ImportDeclaration:l=>{let s=l.specifiers.filter(({type:t})=>t==="ImportSpecifier");if(s.length>1){let t=C(r.options.at(0),{type:p.alphabetical,"ignore-alias":!0,"ignore-case":!1,order:d.asc}),u=r.getSourceCode(),n=s.map(e=>{let{name:a}=e.local;return t["ignore-alias"]&&e.type==="ImportSpecifier"&&({name:a}=e.imported),{size:v(e.range),node:e,name:a}});P(n,(e,a)=>{k(O(e,a,t))&&r.report({messageId:"unexpectedNamedImportsOrder",data:{left:e.name,right:a.name},node:a.node,fix:i=>L(i,n,A(n,t),u)})})}}})});let B=(r,l,s)=>r.lines.slice(l.node.loc.end.line,s.node.loc.start.line-1).filter(u=>!u.trim().length).length;const Y="sort-object-types",xe=j({name:Y,meta:{type:"suggestion",docs:{description:"enforce sorted object types"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},groups:{type:"array",default:[]},"partition-by-new-line":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedObjectTypesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>({TSTypeLiteral:l=>{if(l.members.length>1){let s=C(r.options.at(0),{"partition-by-new-line":!1,type:p.alphabetical,"ignore-case":!1,order:d.asc,"custom-groups":{},groups:[]}),t=r.getSourceCode(),u=l.members.reduce((n,e)=>{var E,b,N,S;let a,i=t.text.slice(e.range.at(0),e.range.at(1)),o=(E=n.at(-1))==null?void 0:E.at(-1),{getGroup:c,defineGroup:y,setCustomGroups:h}=R(s.groups),f=T=>T.replace(/(,|;)$/,"");if(e.type==="TSPropertySignature")e.key.type==="Identifier"?{name:a}=e.key:e.key.type==="Literal"?a=`${e.key.value}`:a=t.text.slice(e.range.at(0),(b=e.typeAnnotation)==null?void 0:b.range.at(0));else if(e.type==="TSIndexSignature"){let T=((N=e.typeAnnotation)==null?void 0:N.range.at(0))??e.range.at(1);a=f(t.text.slice(e.range.at(0),T))}else a=f(t.text.slice(e.range.at(0),e.range.at(1)));h(s["custom-groups"],a),e.loc.start.line!==e.loc.end.line&&y("multiline");let m=i.endsWith(";")||i.endsWith(",")?1:0,w={size:v(e.range)-m,node:e,name:a};return s["partition-by-new-line"]&&o&&B(t,o,w)&&n.push([]),(S=n.at(-1))==null||S.push({...w,group:c()}),n},[[]]);for(let n of u)P(n,(e,a)=>{let i=x(s.groups,e),o=x(s.groups,a);(i>o||i===o&&k(O(e,a,s)))&&r.report({messageId:"unexpectedObjectTypesOrder",data:{left:I(e.name),right:I(a.name)},node:a.node,fix:c=>{let y={};for(let f of n){let g=x(s.groups,f);g in y?y[g]=A([...y[g],f],s):y[g]=[f]}let h=[];for(let f of Object.keys(y).sort())h.push(...A(y[f],s));return L(c,n,h,t)}})})}}})}),Z="sort-union-types",Ee=j({name:Z,meta:{type:"suggestion",docs:{description:"enforce sorted union types"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},"nullable-last":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedUnionTypesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>({TSUnionType:l=>{let s=r.getSourceCode(),t=C(r.options.at(0),{type:p.alphabetical,"nullable-last":!1,"ignore-case":!1,order:d.asc}),u=l.types.map(n=>({group:n.type==="TSNullKeyword"||n.type==="TSUndefinedKeyword"?"nullable":"unknown",name:s.text.slice(...n.range),size:v(n.range),node:n}));P(u,(n,e)=>{let a=k(O(n,e,t));t["nullable-last"]&&(n.group==="nullable"&&e.group==="unknown"?a=!0:n.group==="unknown"&&e.group==="nullable"&&(a=!1)),a&&r.report({messageId:"unexpectedUnionTypesOrder",data:{left:I(n.name),right:I(e.name)},node:e.node,fix:i=>{let o=[];if(t["nullable-last"]){let c=[],y=u.filter(h=>h.group==="nullable"?(c.push(h),!1):!0);o=[...A(y,t),...A(c,t)]}else o=A(u,t);return L(i,u,o,s)}})})}})}),ee="sort-interfaces",Se=j({name:ee,meta:{type:"suggestion",docs:{description:"enforce sorted interface properties"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},"ignore-pattern":{items:{type:"string"},type:"array"},groups:{type:"array",default:[]},"partition-by-new-line":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedInterfacePropertiesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>({TSInterfaceDeclaration:l=>{if(l.body.body.length>1){let s=C(r.options.at(0),{"partition-by-new-line":!1,type:p.alphabetical,"ignore-case":!1,order:d.asc,"ignore-pattern":[],"custom-groups":{},groups:[]});if(!s["ignore-pattern"].some(t=>U.minimatch(l.id.name,t,{nocomment:!0}))){let t=r.getSourceCode(),u=l.body.body.reduce((n,e)=>{var f,g,m,w;if(e.type==="TSCallSignatureDeclaration")return n.push([]),n;let a=(f=n.at(-1))==null?void 0:f.at(-1),i,{getGroup:o,defineGroup:c,setCustomGroups:y}=R(s.groups);if(e.type==="TSPropertySignature")if(e.key.type==="Identifier")({name:i}=e.key);else if(e.key.type==="Literal")i=`${e.key.value}`;else{let E=((g=e.typeAnnotation)==null?void 0:g.range.at(0))??e.range.at(1)-(e.optional?1:0);i=t.text.slice(e.range.at(0),E)}else if(e.type==="TSIndexSignature"){let E=((m=e.typeAnnotation)==null?void 0:m.range.at(0))??e.range.at(1);i=t.text.slice(e.range.at(0),E)}else{let E=((w=e.returnType)==null?void 0:w.range.at(0))??e.range.at(1);i=t.text.slice(e.range.at(0),E)}let h={size:v(e.range),node:e,name:i};return s["partition-by-new-line"]&&a&&B(t,a,h)&&n.push([]),y(s["custom-groups"],i),e.loc.start.line!==e.loc.end.line&&c("multiline"),n.at(-1).push({...h,group:o()}),n},[[]]);for(let n of u)P(n,(e,a)=>{let i=x(s.groups,e),o=x(s.groups,a);(i>o||i===o&&k(O(e,a,s)))&&r.report({messageId:"unexpectedInterfacePropertiesOrder",data:{left:I(e.name),right:I(a.name)},node:a.node,fix:c=>{let y={};for(let f of n){let g=x(s.groups,f);g in y?y[g]=A([...y[g],f],s):y[g]=[f]}let h=[];for(let f of Object.keys(y).sort())h.push(...A(y[f],s));return L(c,n,h,t)}})})}}}})}),te="sort-jsx-props",we=j({name:te,meta:{type:"suggestion",docs:{description:"enforce sorted JSX props"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},groups:{type:"array"},"ignore-case":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedJSXPropsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>[".svelte",".astro",".vue"].includes(W.extname(r.getFilename()))?{}:{JSXElement:l=>{if(l.openingElement.attributes.length>1){let s=C(r.options.at(0),{type:p.alphabetical,"ignore-case":!1,order:d.asc,"custom-groups":{},groups:[]}),t=r.getSourceCode(),u=l.openingElement.attributes.reduce((n,e)=>{if(e.type==="JSXSpreadAttribute")return n.push([]),n;let a=e.name.type==="JSXNamespacedName"?`${e.name.namespace.name}:${e.name.name.name}`:e.name.name,{getGroup:i,defineGroup:o,setCustomGroups:c}=R(s.groups);c(s["custom-groups"],a),e.value===null&&o("shorthand"),e.loc.start.line!==e.loc.end.line&&o("multiline");let y={size:v(e.range),group:i(),node:e,name:a};return n.at(-1).push(y),n},[[]]);for(let n of u)P(n,(e,a)=>{let i=x(s.groups,e),o=x(s.groups,a);(i>o||i===o&&k(O(e,a,s)))&&r.report({messageId:"unexpectedJSXPropsOrder",data:{left:e.name,right:a.name},node:a.node,fix:c=>{let y={};for(let f of n){let g=x(s.groups,f);g in y?y[g]=A([...y[g],f],s):y[g]=[f]}let h=[];for(let f of Object.keys(y).sort())h.push(...A(y[f],s));return L(c,n,h,t)}})})}}}}),re="sort-exports",Ae=j({name:re,meta:{type:"suggestion",docs:{description:"enforce sorted exports"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedExportsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>{let l=C(r.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1}),s=[[]],t=u=>{u.type==="ExportAllDeclaration"&&u.exported===null?s.push([]):s.at(-1).push({size:v(u.range),name:u.source.value,node:u})};return{ExportAllDeclaration:t,ExportNamedDeclaration:u=>{u.source!==null&&t(u)},"Program:exit":()=>{let u=r.getSourceCode();for(let n of s)P(n,(e,a)=>{k(O(e,a,l))&&r.report({messageId:"unexpectedExportsOrder",data:{left:e.name,right:a.name},node:a.node,fix:i=>L(i,n,A(n,l),u)})})}}}}),se="sort-imports",Ne=j({name:se,meta:{type:"suggestion",docs:{description:"enforce sorted imports"},fixable:"code",schema:[{id:"sort-imports",type:"object",properties:{"custom-groups":{type:"object",properties:{type:{type:"object"},value:{type:"object"}},additionalProperties:!1},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},groups:{type:"array",default:[]},"internal-pattern":{items:{type:"string"},type:"array"},"newlines-between":{enum:["ignore","always","never"],default:"always",type:"string"},"max-line-length":{type:"integer",minimum:0,exclusiveMinimum:!0}},allOf:[{$ref:"#/definitions/max-line-length-requires-line-length-type"}],additionalProperties:!1,dependencies:{"max-line-length":["type"]},definitions:{"is-line-length":{properties:{type:{enum:[p["line-length"]],type:"string"}},required:["type"],type:"object"},"max-line-length-requires-line-length-type":{anyOf:[{not:{required:["max-line-length"],type:"object"},type:"object"},{$ref:"#/definitions/is-line-length"}]}}}],messages:{unexpectedImportsOrder:'Expected "{{right}}" to come before "{{left}}"',missedSpacingBetweenImports:'Missed spacing between "{{left}}" and "{{right}}" imports',extraSpacingBetweenImports:'Extra spacing between "{{left}}" and "{{right}}" imports'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>{let l=C(r.options.at(0),{"newlines-between":"always","custom-groups":{type:{},value:{}},"internal-pattern":["~/**"],type:p.alphabetical,order:d.asc,"ignore-case":!1,groups:[]}),s=!1;for(let o of l.groups)if(Array.isArray(o))for(let c of o)c==="unknown"&&(s=!0);else o==="unknown"&&(s=!0);s||(l.groups=[...l.groups,"unknown"]);let t=r.getSourceCode(),u=[],n=o=>o.type==="ImportDeclaration"&&o.specifiers.length===0,e=o=>{let c=S=>[".less",".scss",".sass",".styl",".pcss",".css",".sss"].some(T=>S.endsWith(T)),y=S=>["./index.d.js","./index.d.ts","./index.js","./index.ts","./index","./","."].includes(S),h=S=>S.indexOf("..")===0,f=S=>S.indexOf("./")===0,{getGroup:g,defineGroup:m,setCustomGroups:w}=R(l.groups),E=S=>l["internal-pattern"].length&&l["internal-pattern"].some(T=>U.minimatch(S.source.value,T,{nocomment:!0})),b=S=>{let T=["bun","bun:ffi","bun:jsc","bun:sqlite","bun:test","bun:wrap","detect-libc","undici","ws"];return ce.builtinModules.includes(S.startsWith("node:")?S.split("node:")[1]:S)||T.includes(S)},N=S=>!(S.startsWith(".")||S.startsWith("/"));return o.importKind==="type"&&(o.type==="ImportDeclaration"&&(w(l["custom-groups"].type,o.source.value),y(o.source.value)&&m("index-type"),f(o.source.value)&&m("sibling-type"),h(o.source.value)&&m("parent-type"),E(o)&&m("internal-type"),b(o.source.value)&&m("builtin-type"),N(o.source.value)&&m("external-type")),m("type")),o.type==="ImportDeclaration"&&(w(l["custom-groups"].value,o.source.value),n(o)&&m("side-effect"),c(o.source.value)&&m("style"),y(o.source.value)&&m("index"),f(o.source.value)&&m("sibling"),h(o.source.value)&&m("parent"),E(o)&&m("internal"),b(o.source.value)&&m("builtin"),N(o.source.value)&&m("external")),g()},a=o=>o.specifiers.length>1,i=o=>{let c;o.type==="ImportDeclaration"?c=o.source.value:o.moduleReference.type==="TSExternalModuleReference"&&o.moduleReference.expression.type==="Literal"?c=`${o.moduleReference.expression.value}`:c=t.text.slice(...o.moduleReference.range),u.push({size:v(o.range),group:e(o),name:c,node:o,...l.type===p["line-length"]&&l["max-line-length"]&&{hasMultipleImportDeclarations:a(o)}})};return{TSImportEqualsDeclaration:i,ImportDeclaration:i,"Program:exit":()=>{var h;let o=(f,g)=>!!t.getTokensBetween(f.node,V(g.node,t)||g.node,{includeComments:!0}).length,c=(f,g)=>{let m=[],w={};for(let b of g){let N=x(l.groups,b);N in w?w[N]=A([...w[N],b],l):w[N]=[b]}let E=Object.keys(w).sort().reduce((b,N)=>[...b,...w[N]],[]);for(let b=0,N=E.length;b<N;b++){let S=E.at(b);if(m.push(f.replaceTextRange(M(g.at(b).node,t),t.text.slice(...M(S.node,t)))),l["newlines-between"]!=="ignore"){let T=E.at(b+1);if(T){let G=B(t,g.at(b),g.at(b+1));(l["newlines-between"]==="always"&&x(l.groups,S)===x(l.groups,T)&&G!==0||l["newlines-between"]==="never"&&G>0)&&m.push(f.removeRange([M(g.at(b).node,t).at(1),M(g.at(b+1).node,t).at(0)-1])),l["newlines-between"]==="always"&&x(l.groups,S)!==x(l.groups,T)&&G>1&&m.push(f.replaceTextRange([M(g.at(b).node,t).at(1),M(g.at(b+1).node,t).at(0)-1],`
-`)),l["newlines-between"]==="always"&&x(l.groups,S)!==x(l.groups,T)&&G===0&&m.push(f.insertTextAfterRange(M(g.at(b).node,t),`
-`))}}}return m},y=[[]];for(let f of u){let g=(h=y.at(-1))==null?void 0:h.at(-1);g&&o(g,f)?y.push([f]):y.at(-1).push(f)}for(let f of y)P(f,(g,m)=>{let w=x(l.groups,g),E=x(l.groups,m),b=B(t,g,m);!(n(g.node)&&n(m.node))&&!o(g,m)&&(w>E||w===E&&k(O(g,m,l)))&&r.report({messageId:"unexpectedImportsOrder",data:{left:g.name,right:m.name},node:m.node,fix:N=>c(N,f)}),l["newlines-between"]==="never"&&b>0&&r.report({messageId:"extraSpacingBetweenImports",data:{left:g.name,right:m.name},node:m.node,fix:N=>c(N,f)}),l["newlines-between"]==="always"&&(w<E&&b===0?r.report({messageId:"missedSpacingBetweenImports",data:{left:g.name,right:m.name},node:m.node,fix:N=>c(N,f)}):(b>1||w===E&&b>0)&&r.report({messageId:"extraSpacingBetweenImports",data:{left:g.name,right:m.name},node:m.node,fix:N=>c(N,f)}))})}}}}),ae="sort-objects",Oe=j({name:ae,meta:{type:"suggestion",docs:{description:"enforce sorted objects"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},"partition-by-comment":{type:["boolean","string","array"],default:!1},"partition-by-new-line":{type:"boolean",default:!1},"styled-components":{type:"boolean",default:!0},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},groups:{type:"array"}},additionalProperties:!1}],messages:{unexpectedObjectsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>{let l=s=>{if(s.properties.length>1){let t=C(r.options.at(0),{"partition-by-new-line":!1,"partition-by-comment":!1,type:p.alphabetical,"styled-components":!0,"ignore-case":!1,order:d.asc,"custom-groups":{},groups:[]}),u=i=>i.type==="Identifier"&&i.name==="styled",n=i=>i!==void 0&&i.type==="CallExpression"&&(i.callee.type==="MemberExpression"&&u(i.callee.object)||i.callee.type==="CallExpression"&&u(i.callee.callee));if(!t["styled-components"]&&(n(s.parent)||s.parent.type==="ArrowFunctionExpression"&&n(s.parent.parent)))return;let e=r.getSourceCode(),a=i=>i.reduce((o,c)=>{var S;if(c.type==="SpreadElement"||c.type==="RestElement")return o.push([]),o;let y=V(c,e),h=(S=o.at(-1))==null?void 0:S.at(-1);t["partition-by-comment"]&&y&&pe(t["partition-by-comment"],y.value)&&o.push([]);let f,g="ignore",m=[],{getGroup:w,setCustomGroups:E}=R(t.groups);c.key.type==="Identifier"?{name:f}=c.key:c.key.type==="Literal"?f=`${c.key.value}`:f=e.text.slice(...c.key.range);let b={size:v(c.range),node:c,name:f};t["partition-by-new-line"]&&h&&B(e,h,b)&&o.push([]),c.value.type==="AssignmentPattern"&&(G=>{G.right.type==="Identifier"&&m.push(G.right.name);let ie=$=>{let D=[];switch($.type){case"ArrowFunctionExpression":D.push($.body);break;case"ConditionalExpression":D.push($.consequent,$.alternate);break;case"LogicalExpression":case"BinaryExpression":D.push($.left,$.right);break;case"CallExpression":D.push(...$.arguments);break}D.forEach(z=>{z.type==="Identifier"&&m.push(z.name),(z.type==="BinaryExpression"||z.type==="ConditionalExpression")&&ie(z)})};switch(G.right.type){case"ArrowFunctionExpression":case"ConditionalExpression":case"LogicalExpression":case"BinaryExpression":case"CallExpression":ie(G.right);break}})(c.value),E(t["custom-groups"],f);let N={...b,group:w(),dependencies:m,position:g};return o.at(-1).push(N),o},[[]]);for(let i of a(s.properties))P(i,(o,c)=>{let y=x(t.groups,o),h=x(t.groups,c);if(y>h||y===h&&k(O(o,c,t))){let f=g=>{let m={};for(let E of i){let b=x(t.groups,E);b in m?m[b]=A([...m[b],E],t):m[b]=[E]}let w=[];for(let E of Object.keys(m).sort())w.push(...A(m[E],t));return L(g,i,w,e,{partitionComment:t["partition-by-comment"]})};r.report({messageId:"unexpectedObjectsOrder",data:{left:I(o.name),right:I(c.name)},node:c.node,fix:f})}})}};return{ObjectExpression:l,ObjectPattern:l}}}),ne="sort-classes",Ie=j({name:ne,meta:{type:"suggestion",docs:{description:"enforce sorted classes"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},"ignore-case":{type:"boolean",default:!1},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},groups:{type:"array",default:[]}},additionalProperties:!1}],messages:{unexpectedClassesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>({ClassBody:l=>{if(l.body.length>1){let s=C(r.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1,groups:["property","constructor","method","unknown"]}),t=r.getSourceCode(),u=l.body.map(n=>{var c;let e,{getGroup:a,defineGroup:i}=R(s.groups);n.type==="StaticBlock"?e="static":n.type==="TSIndexSignature"?e=t.text.slice(n.range.at(0),((c=n.typeAnnotation)==null?void 0:c.range.at(0))??n.range.at(1)):n.key.type==="Identifier"?{name:e}=n.key:e=t.text.slice(...n.key.range);let o=e.startsWith("_")||e.startsWith("#");if(n.type==="MethodDefinition"){n.kind==="constructor"&&i("constructor");let y=n.accessibility==="private"||o,h=n.static;y&&h&&i("static-private-method"),y&&i("private-method"),h&&i("static-method"),n.kind==="get"&&i("get-method"),n.kind==="set"&&i("set-method"),i("method")}else n.type==="TSIndexSignature"?i("index-signature"):n.type==="PropertyDefinition"&&((n.accessibility==="private"||o)&&i("private-property"),n.static&&i("static-property"),i("property"));return{size:v(n.range),group:a(),node:n,name:e}});P(u,(n,e)=>{let a=x(s.groups,n),i=x(s.groups,e);n.name!==e.name&&(a>i||a===i&&k(O(n,e,s)))&&r.report({messageId:"unexpectedClassesOrder",data:{left:I(n.name),right:I(e.name)},node:e.node,fix:o=>{let c=[],y=u.reduce((f,g)=>{let m=x(s.groups,g);return m in f?f[m]=A([...f[m],g],s):f[m]=[g],f},{}),h=Object.keys(y).sort().reduce((f,g)=>[...f,...y[g]],[]);for(let f=0,g=h.length;f<g;f++)c.push(o.replaceTextRange(M(u.at(f).node,t),t.text.slice(...M(h.at(f).node,t))));return c}})})}}})}),oe="sort-enums",je=j({name:oe,meta:{type:"suggestion",docs:{description:"enforce sorted TypeScript enums"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},"ignore-case":{type:"boolean",default:!1},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"}},additionalProperties:!1}],messages:{unexpectedEnumsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>({TSEnumDeclaration:l=>{if(l.members.length>1&&l.members.every(({initializer:s})=>s)){let s=C(r.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1}),t=r.getSourceCode(),u=l.members.map(n=>({name:n.id.type==="Literal"?`${n.id.value}`:`${t.text.slice(...n.id.range)}`,size:v(n.range),node:n}));P(u,(n,e)=>{k(O(n,e,s))&&r.report({messageId:"unexpectedEnumsOrder",data:{left:I(n.name),right:I(e.name)},node:e.node,fix:a=>L(a,u,A(u,s),t)})})}}})}),le="sort-maps",ve=j({name:le,meta:{type:"suggestion",docs:{description:"enforce sorted Map elements"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedMapElementsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:r=>({NewExpression:l=>{if(l.callee.type==="Identifier"&&l.callee.name==="Map"&&l.arguments.length&&l.arguments[0].type==="ArrayExpression"){let[{elements:s}]=l.arguments;if(s.length>1){let t=C(r.options.at(0),{type:p.alphabetical,"ignore-case":!1,order:d.asc}),u=r.getSourceCode(),n=s.reduce((e,a)=>(a===null||a.type==="SpreadElement"?e.push([]):e.at(-1).push(a),e),[[]]);for(let e of n){let a=e.map(i=>{let o;if(i.type==="ArrayExpression"){let[c]=i.elements;c?c.type==="Literal"?o=c.raw:o=u.text.slice(...c.range):o=`${c}`}else o=u.text.slice(...i.range);return{size:v(i.range),node:i,name:o}});P(a,(i,o)=>{k(O(i,o,t))&&r.report({messageId:"unexpectedMapElementsOrder",data:{left:I(i.name),right:I(o.name)},node:o.node,fix:c=>L(c,a,A(a,t),u)})})}}}}})}),ke="eslint-plugin-perfectionist";let q=r=>{let l={[se]:["error",{groups:["type",["builtin","external"],"internal-type","internal",["parent-type","sibling-type","index-type"],["parent","sibling","index"],"object","unknown"],"custom-groups":{value:{},type:{}},"newlines-between":"always","internal-pattern":["~/**"]}],[ne]:["error",{groups:["index-signature","static-property","private-property","property","constructor","static-method","private-method","method",["get-method","set-method"],"unknown"]}],[ae]:["error",{"partition-by-comment":!1}],[K]:["error",{"spread-last":!0}],[J]:["error"],[X]:["error"],[F]:["error"],[H]:["error"],[Q]:["error"],[Y]:["error"],[Z]:["error"],[ee]:["error"],[te]:["error"],[re]:["error"],[oe]:["error"],[le]:["error"]};return{rules:Object.fromEntries(Object.entries(l).map(([s,[t,u={}]])=>[`perfectionist/${s}`,[t,Object.assign(u,r)]])),plugins:["perfectionist"]}};const Ce={rules:{[K]:ye,[X]:ge,[ne]:Ie,[oe]:je,[re]:Ae,[se]:Ne,[ee]:Se,[te]:we,[le]:ve,[H]:he,[Q]:be,[Y]:xe,[ae]:Oe,[J]:fe,[Z]:Ee,[F]:me},configs:{"recommended-alphabetical":q({type:p.alphabetical,order:d.asc,"ignore-case":!1}),"recommended-natural":q({type:p.natural,order:d.asc,"ignore-case":!1}),"recommended-line-length":q({type:p["line-length"],order:d.desc})},name:ke};module.exports=Ce;
+"use strict";const W=require("node:path"),_=require("@typescript-eslint/utils"),U=require("minimatch"),ce=require("natural-compare-lite"),de=require("node:module");let v=_.ESLintUtils.RuleCreator(t=>`https://eslint-plugin-perfectionist.azat.io/rules/${t}`),x=(t,l)=>{for(let s=0,r=t.length;s<r;s++){let c=t[s];if(l.group===c||Array.isArray(c)&&typeof l.group=="string"&&c.includes(l.group))return s}return t.length},k=t=>{let[l,s]=t;return s-l},N=t=>t>0;var p=(t=>(t.alphabetical="alphabetical",t["line-length"]="line-length",t.natural="natural",t))(p||{}),d=(t=>(t.desc="desc",t.asc="asc",t))(d||{});let G=t=>{let l,s=c=>{!l&&t.flat().includes(c)&&(l=c)};return{getGroup:()=>l??"unknown",setCustomGroups:(c,o)=>{if(c)for(let[e,a]of Object.entries(c))Array.isArray(a)&&a.some(i=>U.minimatch(o,i,{nocomment:!0}))&&s(e),typeof a=="string"&&U.minimatch(o,a,{nocomment:!0})&&s(e)},defineGroup:s}},I=(t,l,s)=>{var e,a;if((e=l.dependencies)!=null&&e.includes(t.name))return-1;if((a=t.dependencies)!=null&&a.includes(l.name))return 1;let r=s.order==="asc"?1:-1,c,o=i=>s["ignore-case"]?i.toLowerCase():i;return s.type===p.alphabetical?c=(i,n)=>o(i.name).localeCompare(o(n.name)):s.type===p.natural?c=(i,n)=>ce(o(i.name),o(n.name)):c=(i,n)=>{let u=i.size,g=n.size,h=s["max-line-length"];if(i.sortRule==="sort-import"&&i.text&&(u=pe(i.text)),n.sortRule==="sort-import"&&n.text&&(g=pe(n.text)),h){let f=(y,m)=>y>h&&m.hasMultipleImportDeclarations;f(u,i)&&!t.text&&(u=i.name.length+10),f(g,n)&&!l.text&&(g=n.name.length+10),i.sortRule==="sort-import"&&i.text&&f(i.text.length,i)&&(u=u/10),n.sortRule==="sort-import"&&n.text&&f(n.text.length,n)&&(g=g/10)}return u-g},r*c(t,l)};const pe=t=>{const l=t.split("from").at(0).length*1e3;return t.split("import * as").length>1?l/100:t.split("import {").length===1?l/10:l};let A=(t,l)=>[...t].sort((s,r)=>I(s,r,l)),fe=(t,l)=>{let s=l.getTokenAfter(t,{filter:({value:r,type:c})=>!(c==="Punctuator"&&[",",";"].includes(r)),includeComments:!0});return((s==null?void 0:s.type)==="Block"||(s==null?void 0:s.type)==="Line")&&t.loc.end.line===s.loc.end.line?s:null},ue=(t,l)=>Array.isArray(t)&&t.some(s=>U.minimatch(l.trim(),s,{nocomment:!0}))||typeof t=="string"&&U.minimatch(l.trim(),t,{nocomment:!0})||t===!0,V=(t,l)=>{let[s,r]=l.getTokensBefore(t,{filter:({value:c,type:o})=>!(o==="Punctuator"&&[",",";"].includes(c)),includeComments:!0,count:2});return((r==null?void 0:r.type)==="Block"||(r==null?void 0:r.type)==="Line")&&t.loc.start.line-r.loc.end.line<=1&&(s==null?void 0:s.loc.end.line)!==r.loc.start.line?r:null},M=(t,l,s)=>{var a;let r=t.range.at(0),c=t.range.at(1),o=l.text.slice(r,c);if(_.ASTUtils.isParenthesized(t,l)){let i=l.getTokenBefore(t,_.ASTUtils.isOpeningParenToken),n=l.getTokenAfter(t,_.ASTUtils.isClosingParenToken);r=i.range.at(0),c=n.range.at(1)}let e=V(t,l);if(o.endsWith(";")||o.endsWith(",")){let i=l.getTokensAfter(t,{includeComments:!0,count:2});t.loc.start.line===((a=i.at(1))==null?void 0:a.loc.start.line)&&(c-=1)}return e&&!ue((s==null?void 0:s.partitionComment)??!1,e.value)&&(r=e.range.at(0)),[r,c]},L=(t,l,s,r,c)=>{var a,i;let o=[],e=((a=l.at(0))==null?void 0:a.node.loc.start.line)===((i=l.at(-1))==null?void 0:i.node.loc.end.line);for(let n=0,u=l.length;n<u;n++){let{node:g}=l.at(n);o.push(t.replaceTextRange(M(g,r,c),r.text.slice(...M(s.at(n).node,r,c))));let h=fe(s.at(n).node,r);if(h&&!e){let y=[r.getTokenBefore(h).range.at(1),h.range.at(1)];o.push(t.replaceTextRange(y,""));let m=r.getTokenAfter(g);o.push(t.insertTextAfter((m==null?void 0:m.loc.end.line)===g.loc.end.line?m:g,r.text.slice(...y)))}}return o},C=(t={},l)=>Object.assign(l,t),P=(t,l)=>{if(t.length>1)for(let s=1;s<t.length;s++){let r=t.at(s-1),c=t.at(s);r&&c&&l(r,c,s-1)}};const J="sort-svelte-attributes",ge=v({name:J,meta:{type:"suggestion",docs:{description:"enforce sorted Svelte attributes"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},groups:{type:"array"}},additionalProperties:!1}],messages:{unexpectedSvelteAttributesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>W.extname(t.getFilename())!==".svelte"?{}:{SvelteStartTag:l=>{if(l.attributes.length>1){let s=C(t.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1,"custom-groups":{},groups:[]}),r=t.getSourceCode(),c=l.attributes.reduce((o,e)=>{if(e.type==="SvelteSpreadAttribute")return o.push([]),o;let a,{getGroup:i,defineGroup:n,setCustomGroups:u}=G(s.groups);return e.key.type==="SvelteSpecialDirectiveKey"?a=r.text.slice(...e.key.range):typeof e.key.name=="string"?{name:a}=e.key:a=r.text.slice(...e.key.range),u(s["custom-groups"],a),e.type==="SvelteShorthandAttribute"&&(n("svelte-shorthand"),n("shorthand")),(!("value"in e)||Array.isArray(e.value)&&!e.value.at(0))&&n("shorthand"),e.loc.start.line!==e.loc.end.line&&n("multiline"),o.at(-1).push({size:k(e.range),node:e,group:i(),name:a}),o},[[]]);for(let o of c)P(o,(e,a)=>{let i=x(s.groups,e),n=x(s.groups,a);(i>n||i===n&&N(I(e,a,s)))&&t.report({messageId:"unexpectedSvelteAttributesOrder",data:{left:e.name,right:a.name},node:a.node,fix:u=>{let g={};for(let f of o){let y=x(s.groups,f);y in g?g[y]=A([...g[y],f],s):g[y]=[f]}let h=[];for(let f of Object.keys(g).sort())h.push(...A(g[f],s));return L(u,o,h,r)}})})}}}}),X="sort-astro-attributes",ye=v({name:X,meta:{type:"suggestion",docs:{description:"enforce sorted Astro attributes"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},groups:{type:"array"}},additionalProperties:!1}],messages:{unexpectedAstroAttributesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>W.extname(t.getFilename())!==".astro"?{}:{JSXElement:l=>{let{attributes:s}=l.openingElement;if(s.length>1){let r=C(t.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1,"custom-groups":{},groups:[]}),c=t.getSourceCode(),o=s.reduce((e,a)=>{if(a.type==="JSXSpreadAttribute")return e.push([]),e;let i=typeof a.name.name=="string"?a.name.name:c.text.slice(...a.name.range),{getGroup:n,defineGroup:u,setCustomGroups:g}=G(r.groups);return g(r["custom-groups"],i),a.type==="AstroShorthandAttribute"&&(u("astro-shorthand"),u("shorthand")),a.value===null&&u("shorthand"),a.loc.start.line!==a.loc.end.line&&u("multiline"),e.at(-1).push({size:k(a.range),node:a,group:n(),name:i}),e},[[]]);for(let e of o)P(e,(a,i)=>{let n=x(r.groups,a),u=x(r.groups,i);(n>u||n===u&&N(I(a,i,r)))&&t.report({messageId:"unexpectedAstroAttributesOrder",data:{left:a.name,right:i.name},node:i.node,fix:g=>{let h={};for(let y of e){let m=x(r.groups,y);m in h?h[m]=A([...h[m],y],r):h[m]=[y]}let f=[];for(let y of Object.keys(h).sort())f.push(...A(h[y],r));return L(g,e,f,c)}})})}}}});let j=t=>t.replaceAll(/\s\s+/g," ").trim();const K="sort-array-includes",me=v({name:K,meta:{type:"suggestion",docs:{description:"enforce sorted arrays before include method"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},"spread-last":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedArrayIncludesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>({MemberExpression:l=>{if((l.object.type==="ArrayExpression"||l.object.type==="NewExpression")&&l.property.type==="Identifier"&&l.property.name==="includes"){let s=l.object.type==="ArrayExpression"?l.object.elements:l.object.arguments;if(s.length>1){let r=C(t.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1,"spread-last":!1}),c=t.getSourceCode(),o=s.reduce((e,a)=>(a!==null&&e.at(0).push({name:a.type==="Literal"?`${a.value}`:c.text.slice(...a.range),size:k(a.range),type:a.type,node:a}),e),[[],[]]).flat();P(o,(e,a)=>{let i;r["spread-last"]&&e.node.type==="Literal"&&a.node.type==="SpreadElement"?i=!1:r["spread-last"]&&e.node.type==="SpreadElement"&&a.node.type==="Literal"?i=!0:i=N(I(e,a,r)),i&&t.report({messageId:"unexpectedArrayIncludesOrder",data:{left:j(e.name),right:j(a.name)},node:a.node,fix:n=>{let u=A(o,r);if(r["spread-last"])for(let g=0,h=u.length;g<h;g++)u.at(g).node.type==="SpreadElement"&&u.push(u.splice(g,1).at(0));return L(n,o,u,c)}})})}}}})}),F="sort-vue-attributes",he=v({name:F,meta:{type:"suggestion",docs:{description:"enforce sorted Vue attributes"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},groups:{type:"array",default:[]}},additionalProperties:!1}],messages:{unexpectedVueAttributesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>{if(W.extname(t.getFilename())!==".vue")return{};if(!("defineTemplateBodyVisitor"in t.parserServices))return{};let{defineTemplateBodyVisitor:l}=t.parserServices;return l({VStartTag:s=>{if(s.attributes.length>1){let r=C(t.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1,"custom-groups":{},groups:[]}),c=t.getSourceCode(),o=s.attributes.reduce((e,a)=>{if(a.key.type==="VDirectiveKey"&&a.key.name.rawName==="bind")return e.push([]),e;let i,{getGroup:n,defineGroup:u,setCustomGroups:g}=G(r.groups);return typeof a.key.name=="string"&&a.key.type!=="VDirectiveKey"?i=a.key.rawName:i=c.text.slice(...a.key.range),g(r["custom-groups"],i),a.value===null&&u("shorthand"),a.loc.start.line!==a.loc.end.line&&u("multiline"),e.at(-1).push({size:k(a.range),node:a,group:n(),name:i}),e},[[]]);for(let e of o)P(e,(a,i)=>{let n=x(r.groups,a),u=x(r.groups,i);(n>u||n===u&&N(I(a,i,r)))&&t.report({messageId:"unexpectedVueAttributesOrder",data:{left:a.name,right:i.name},node:i.node,fix:g=>{let h={};for(let y of e){let m=x(r.groups,y);m in h?h[m]=A([...h[m],y],r):h[m]=[y]}let f=[];for(let y of Object.keys(h).sort())f.push(...A(h[y],r));return L(g,e,f,c)}})})}}})}}),H="sort-named-exports",be=v({name:H,meta:{type:"suggestion",docs:{description:"enforce sorted named exports"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedNamedExportsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>({ExportNamedDeclaration:l=>{if(l.specifiers.length>1){let s=C(t.options.at(0),{type:p.alphabetical,"ignore-case":!1,order:d.asc}),r=t.getSourceCode(),c=l.specifiers.map(o=>({size:k(o.range),name:o.local.name,node:o}));P(c,(o,e)=>{N(I(o,e,s))&&t.report({messageId:"unexpectedNamedExportsOrder",data:{left:o.name,right:e.name},node:e.node,fix:a=>L(a,c,A(c,s),r)})})}}})}),Q="sort-named-imports",xe=v({name:Q,meta:{type:"suggestion",docs:{description:"enforce sorted named imports"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},"ignore-alias":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedNamedImportsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>({ImportDeclaration:l=>{let s=l.specifiers.filter(({type:r})=>r==="ImportSpecifier");if(s.length>1){let r=C(t.options.at(0),{type:p.alphabetical,"ignore-alias":!0,"ignore-case":!1,order:d.asc}),c=t.getSourceCode(),o=s.map(e=>{let{name:a}=e.local;return r["ignore-alias"]&&e.type==="ImportSpecifier"&&({name:a}=e.imported),{size:k(e.range),node:e,name:a}});P(o,(e,a)=>{N(I(e,a,r))&&t.report({messageId:"unexpectedNamedImportsOrder",data:{left:e.name,right:a.name},node:a.node,fix:i=>L(i,o,A(o,r),c)})})}}})});let B=(t,l,s)=>t.lines.slice(l.node.loc.end.line,s.node.loc.start.line-1).filter(c=>!c.trim().length).length;const Y="sort-object-types",Ee=v({name:Y,meta:{type:"suggestion",docs:{description:"enforce sorted object types"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},groups:{type:"array",default:[]},"partition-by-new-line":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedObjectTypesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>({TSTypeLiteral:l=>{if(l.members.length>1){let s=C(t.options.at(0),{"partition-by-new-line":!1,type:p.alphabetical,"ignore-case":!1,order:d.asc,"custom-groups":{},groups:[]}),r=t.getSourceCode(),c=l.members.reduce((o,e)=>{var E,b,O,S;let a,i=r.text.slice(e.range.at(0),e.range.at(1)),n=(E=o.at(-1))==null?void 0:E.at(-1),{getGroup:u,defineGroup:g,setCustomGroups:h}=G(s.groups),f=T=>T.replace(/(,|;)$/,"");if(e.type==="TSPropertySignature")e.key.type==="Identifier"?{name:a}=e.key:e.key.type==="Literal"?a=`${e.key.value}`:a=r.text.slice(e.range.at(0),(b=e.typeAnnotation)==null?void 0:b.range.at(0));else if(e.type==="TSIndexSignature"){let T=((O=e.typeAnnotation)==null?void 0:O.range.at(0))??e.range.at(1);a=f(r.text.slice(e.range.at(0),T))}else a=f(r.text.slice(e.range.at(0),e.range.at(1)));h(s["custom-groups"],a),e.loc.start.line!==e.loc.end.line&&g("multiline");let m=i.endsWith(";")||i.endsWith(",")?1:0,w={size:k(e.range)-m,node:e,name:a};return s["partition-by-new-line"]&&n&&B(r,n,w)&&o.push([]),(S=o.at(-1))==null||S.push({...w,group:u()}),o},[[]]);for(let o of c)P(o,(e,a)=>{let i=x(s.groups,e),n=x(s.groups,a);(i>n||i===n&&N(I(e,a,s)))&&t.report({messageId:"unexpectedObjectTypesOrder",data:{left:j(e.name),right:j(a.name)},node:a.node,fix:u=>{let g={};for(let f of o){let y=x(s.groups,f);y in g?g[y]=A([...g[y],f],s):g[y]=[f]}let h=[];for(let f of Object.keys(g).sort())h.push(...A(g[f],s));return L(u,o,h,r)}})})}}})}),Z="sort-union-types",Se=v({name:Z,meta:{type:"suggestion",docs:{description:"enforce sorted union types"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},"nullable-last":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedUnionTypesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>({TSUnionType:l=>{let s=t.getSourceCode(),r=C(t.options.at(0),{type:p.alphabetical,"nullable-last":!1,"ignore-case":!1,order:d.asc}),c=l.types.map(o=>({group:o.type==="TSNullKeyword"||o.type==="TSUndefinedKeyword"?"nullable":"unknown",name:s.text.slice(...o.range),size:k(o.range),node:o}));P(c,(o,e)=>{let a=N(I(o,e,r));r["nullable-last"]&&(o.group==="nullable"&&e.group==="unknown"?a=!0:o.group==="unknown"&&e.group==="nullable"&&(a=!1)),a&&t.report({messageId:"unexpectedUnionTypesOrder",data:{left:j(o.name),right:j(e.name)},node:e.node,fix:i=>{let n=[];if(r["nullable-last"]){let u=[],g=c.filter(h=>h.group==="nullable"?(u.push(h),!1):!0);n=[...A(g,r),...A(u,r)]}else n=A(c,r);return L(i,c,n,s)}})})}})}),ee="sort-interfaces",we=v({name:ee,meta:{type:"suggestion",docs:{description:"enforce sorted interface properties"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},"ignore-pattern":{items:{type:"string"},type:"array"},groups:{type:"array",default:[]},"partition-by-new-line":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedInterfacePropertiesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>({TSInterfaceDeclaration:l=>{if(l.body.body.length>1){let s=C(t.options.at(0),{"partition-by-new-line":!1,type:p.alphabetical,"ignore-case":!1,order:d.asc,"ignore-pattern":[],"custom-groups":{},groups:[]});if(!s["ignore-pattern"].some(r=>U.minimatch(l.id.name,r,{nocomment:!0}))){let r=t.getSourceCode(),c=l.body.body.reduce((o,e)=>{var f,y,m,w;if(e.type==="TSCallSignatureDeclaration")return o.push([]),o;let a=(f=o.at(-1))==null?void 0:f.at(-1),i,{getGroup:n,defineGroup:u,setCustomGroups:g}=G(s.groups);if(e.type==="TSPropertySignature")if(e.key.type==="Identifier")({name:i}=e.key);else if(e.key.type==="Literal")i=`${e.key.value}`;else{let E=((y=e.typeAnnotation)==null?void 0:y.range.at(0))??e.range.at(1)-(e.optional?1:0);i=r.text.slice(e.range.at(0),E)}else if(e.type==="TSIndexSignature"){let E=((m=e.typeAnnotation)==null?void 0:m.range.at(0))??e.range.at(1);i=r.text.slice(e.range.at(0),E)}else{let E=((w=e.returnType)==null?void 0:w.range.at(0))??e.range.at(1);i=r.text.slice(e.range.at(0),E)}let h={size:k(e.range),node:e,name:i};return s["partition-by-new-line"]&&a&&B(r,a,h)&&o.push([]),g(s["custom-groups"],i),e.loc.start.line!==e.loc.end.line&&u("multiline"),o.at(-1).push({...h,group:n()}),o},[[]]);for(let o of c)P(o,(e,a)=>{let i=x(s.groups,e),n=x(s.groups,a);(i>n||i===n&&N(I(e,a,s)))&&t.report({messageId:"unexpectedInterfacePropertiesOrder",data:{left:j(e.name),right:j(a.name)},node:a.node,fix:u=>{let g={};for(let f of o){let y=x(s.groups,f);y in g?g[y]=A([...g[y],f],s):g[y]=[f]}let h=[];for(let f of Object.keys(g).sort())h.push(...A(g[f],s));return L(u,o,h,r)}})})}}}})}),te="sort-jsx-props",Ae=v({name:te,meta:{type:"suggestion",docs:{description:"enforce sorted JSX props"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},groups:{type:"array"},"ignore-case":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedJSXPropsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>[".svelte",".astro",".vue"].includes(W.extname(t.getFilename()))?{}:{JSXElement:l=>{if(l.openingElement.attributes.length>1){let s=C(t.options.at(0),{type:p.alphabetical,"ignore-case":!1,order:d.asc,"custom-groups":{},groups:[]}),r=t.getSourceCode(),c=l.openingElement.attributes.reduce((o,e)=>{if(e.type==="JSXSpreadAttribute")return o.push([]),o;let a=e.name.type==="JSXNamespacedName"?`${e.name.namespace.name}:${e.name.name.name}`:e.name.name,{getGroup:i,defineGroup:n,setCustomGroups:u}=G(s.groups);u(s["custom-groups"],a),e.value===null&&n("shorthand"),e.loc.start.line!==e.loc.end.line&&n("multiline");let g={size:k(e.range),group:i(),node:e,name:a};return o.at(-1).push(g),o},[[]]);for(let o of c)P(o,(e,a)=>{let i=x(s.groups,e),n=x(s.groups,a);(i>n||i===n&&N(I(e,a,s)))&&t.report({messageId:"unexpectedJSXPropsOrder",data:{left:e.name,right:a.name},node:a.node,fix:u=>{let g={};for(let f of o){let y=x(s.groups,f);y in g?g[y]=A([...g[y],f],s):g[y]=[f]}let h=[];for(let f of Object.keys(g).sort())h.push(...A(g[f],s));return L(u,o,h,r)}})})}}}}),re="sort-exports",Oe=v({name:re,meta:{type:"suggestion",docs:{description:"enforce sorted exports"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedExportsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>{let l=C(t.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1}),s=[[]],r=c=>{c.type==="ExportAllDeclaration"&&c.exported===null?s.push([]):s.at(-1).push({size:k(c.range),name:c.source.value,node:c})};return{ExportAllDeclaration:r,ExportNamedDeclaration:c=>{c.source!==null&&r(c)},"Program:exit":()=>{let c=t.getSourceCode();for(let o of s)P(o,(e,a)=>{N(I(e,a,l))&&t.report({messageId:"unexpectedExportsOrder",data:{left:e.name,right:a.name},node:a.node,fix:i=>L(i,o,A(o,l),c)})})}}}}),se="sort-imports",Ie=v({name:se,meta:{type:"suggestion",docs:{description:"enforce sorted imports"},fixable:"code",schema:[{id:"sort-imports",type:"object",properties:{"custom-groups":{type:"object",properties:{type:{type:"object"},value:{type:"object"}},additionalProperties:!1},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},groups:{type:"array",default:[]},"internal-pattern":{items:{type:"string"},type:"array"},"newlines-between":{enum:["ignore","always","never"],default:"always",type:"string"},"max-line-length":{type:"integer",minimum:0,exclusiveMinimum:!0}},allOf:[{$ref:"#/definitions/max-line-length-requires-line-length-type"}],additionalProperties:!1,dependencies:{"max-line-length":["type"]},definitions:{"is-line-length":{properties:{type:{enum:[p["line-length"]],type:"string"}},required:["type"],type:"object"},"max-line-length-requires-line-length-type":{anyOf:[{not:{required:["max-line-length"],type:"object"},type:"object"},{$ref:"#/definitions/is-line-length"}]}}}],messages:{unexpectedImportsOrder:'Expected "{{right}}" to come before "{{left}}"',missedSpacingBetweenImports:'Missed spacing between "{{left}}" and "{{right}}" imports',extraSpacingBetweenImports:'Extra spacing between "{{left}}" and "{{right}}" imports'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>{let l=C(t.options.at(0),{"newlines-between":"always","custom-groups":{type:{},value:{}},"internal-pattern":["~/**"],type:p.alphabetical,order:d.asc,"ignore-case":!1,groups:[]}),s=!1;for(let n of l.groups)if(Array.isArray(n))for(let u of n)u==="unknown"&&(s=!0);else n==="unknown"&&(s=!0);s||(l.groups=[...l.groups,"unknown"]);let r=t.getSourceCode(),c=[],o=n=>n.type==="ImportDeclaration"&&n.specifiers.length===0,e=n=>{let u=S=>[".less",".scss",".sass",".styl",".pcss",".css",".sss"].some(T=>S.endsWith(T)),g=S=>["./index.d.js","./index.d.ts","./index.js","./index.ts","./index","./","."].includes(S),h=S=>S.indexOf("..")===0,f=S=>S.indexOf("./")===0,{getGroup:y,defineGroup:m,setCustomGroups:w}=G(l.groups),E=S=>l["internal-pattern"].length&&l["internal-pattern"].some(T=>U.minimatch(S.source.value,T,{nocomment:!0})),b=S=>{let T=["bun","bun:ffi","bun:jsc","bun:sqlite","bun:test","bun:wrap","detect-libc","undici","ws"];return de.builtinModules.includes(S.startsWith("node:")?S.split("node:")[1]:S)||T.includes(S)},O=S=>!(S.startsWith(".")||S.startsWith("/"));return n.importKind==="type"&&(n.type==="ImportDeclaration"&&(w(l["custom-groups"].type,n.source.value),g(n.source.value)&&m("index-type"),f(n.source.value)&&m("sibling-type"),h(n.source.value)&&m("parent-type"),E(n)&&m("internal-type"),b(n.source.value)&&m("builtin-type"),O(n.source.value)&&m("external-type")),m("type")),n.type==="ImportDeclaration"&&(w(l["custom-groups"].value,n.source.value),o(n)&&m("side-effect"),u(n.source.value)&&m("style"),g(n.source.value)&&m("index"),f(n.source.value)&&m("sibling"),h(n.source.value)&&m("parent"),E(n)&&m("internal"),b(n.source.value)&&m("builtin"),O(n.source.value)&&m("external")),y()},a=n=>n.specifiers.length>1,i=n=>{let u;n.type==="ImportDeclaration"?u=n.source.value:n.moduleReference.type==="TSExternalModuleReference"&&n.moduleReference.expression.type==="Literal"?u=`${n.moduleReference.expression.value}`:u=r.text.slice(...n.moduleReference.range),c.push({sortRule:"sort-import",text:r.getText(n),size:k(n.range),group:e(n),name:u,node:n,...l.type===p["line-length"]&&l["max-line-length"]&&{hasMultipleImportDeclarations:a(n)}})};return{TSImportEqualsDeclaration:i,ImportDeclaration:i,"Program:exit":()=>{var h;let n=(f,y)=>!!r.getTokensBetween(f.node,V(y.node,r)||y.node,{includeComments:!0}).length,u=(f,y)=>{let m=[],w={};for(let b of y){let O=x(l.groups,b);O in w?w[O]=A([...w[O],b],l):w[O]=[b]}let E=Object.keys(w).sort().reduce((b,O)=>[...b,...w[O]],[]);for(let b=0,O=E.length;b<O;b++){let S=E.at(b);if(m.push(f.replaceTextRange(M(y.at(b).node,r),r.text.slice(...M(S.node,r)))),l["newlines-between"]!=="ignore"){let T=E.at(b+1);if(T){let R=B(r,y.at(b),y.at(b+1));(l["newlines-between"]==="always"&&x(l.groups,S)===x(l.groups,T)&&R!==0||l["newlines-between"]==="never"&&R>0)&&m.push(f.removeRange([M(y.at(b).node,r).at(1),M(y.at(b+1).node,r).at(0)-1])),l["newlines-between"]==="always"&&x(l.groups,S)!==x(l.groups,T)&&R>1&&m.push(f.replaceTextRange([M(y.at(b).node,r).at(1),M(y.at(b+1).node,r).at(0)-1],`
+`)),l["newlines-between"]==="always"&&x(l.groups,S)!==x(l.groups,T)&&R===0&&m.push(f.insertTextAfterRange(M(y.at(b).node,r),`
+`))}}}return m},g=[[]];for(let f of c){let y=(h=g.at(-1))==null?void 0:h.at(-1);y&&n(y,f)?g.push([f]):g.at(-1).push(f)}for(let f of g)P(f,(y,m)=>{let w=x(l.groups,y),E=x(l.groups,m),b=B(r,y,m);!(o(y.node)&&o(m.node))&&!n(y,m)&&(w>E||w===E&&N(I(y,m,l)))&&t.report({messageId:"unexpectedImportsOrder",data:{left:y.name,right:m.name},node:m.node,fix:O=>u(O,f)}),l["newlines-between"]==="never"&&b>0&&t.report({messageId:"extraSpacingBetweenImports",data:{left:y.name,right:m.name},node:m.node,fix:O=>u(O,f)}),l["newlines-between"]==="always"&&(w<E&&b===0?t.report({messageId:"missedSpacingBetweenImports",data:{left:y.name,right:m.name},node:m.node,fix:O=>u(O,f)}):(b>1||w===E&&b>0)&&t.report({messageId:"extraSpacingBetweenImports",data:{left:y.name,right:m.name},node:m.node,fix:O=>u(O,f)}))})}}}}),ae="sort-objects",je=v({name:ae,meta:{type:"suggestion",docs:{description:"enforce sorted objects"},fixable:"code",schema:[{type:"object",properties:{"custom-groups":{type:"object"},"partition-by-comment":{type:["boolean","string","array"],default:!1},"partition-by-new-line":{type:"boolean",default:!1},"styled-components":{type:"boolean",default:!0},type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1},groups:{type:"array"}},additionalProperties:!1}],messages:{unexpectedObjectsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>{let l=s=>{if(s.properties.length>1){let r=C(t.options.at(0),{"partition-by-new-line":!1,"partition-by-comment":!1,type:p.alphabetical,"styled-components":!0,"ignore-case":!1,order:d.asc,"custom-groups":{},groups:[]}),c=i=>i.type==="Identifier"&&i.name==="styled",o=i=>i!==void 0&&i.type==="CallExpression"&&(i.callee.type==="MemberExpression"&&c(i.callee.object)||i.callee.type==="CallExpression"&&c(i.callee.callee));if(!r["styled-components"]&&(o(s.parent)||s.parent.type==="ArrowFunctionExpression"&&o(s.parent.parent)))return;let e=t.getSourceCode(),a=i=>i.reduce((n,u)=>{var S;if(u.type==="SpreadElement"||u.type==="RestElement")return n.push([]),n;let g=V(u,e),h=(S=n.at(-1))==null?void 0:S.at(-1);r["partition-by-comment"]&&g&&ue(r["partition-by-comment"],g.value)&&n.push([]);let f,y="ignore",m=[],{getGroup:w,setCustomGroups:E}=G(r.groups);u.key.type==="Identifier"?{name:f}=u.key:u.key.type==="Literal"?f=`${u.key.value}`:f=e.text.slice(...u.key.range);let b={size:k(u.range),node:u,name:f};r["partition-by-new-line"]&&h&&B(e,h,b)&&n.push([]),u.value.type==="AssignmentPattern"&&(R=>{R.right.type==="Identifier"&&m.push(R.right.name);let ie=$=>{let z=[];switch($.type){case"ArrowFunctionExpression":z.push($.body);break;case"ConditionalExpression":z.push($.consequent,$.alternate);break;case"LogicalExpression":case"BinaryExpression":z.push($.left,$.right);break;case"CallExpression":z.push(...$.arguments);break}z.forEach(D=>{D.type==="Identifier"&&m.push(D.name),(D.type==="BinaryExpression"||D.type==="ConditionalExpression")&&ie(D)})};switch(R.right.type){case"ArrowFunctionExpression":case"ConditionalExpression":case"LogicalExpression":case"BinaryExpression":case"CallExpression":ie(R.right);break}})(u.value),E(r["custom-groups"],f);let O={...b,group:w(),dependencies:m,position:y};return n.at(-1).push(O),n},[[]]);for(let i of a(s.properties))P(i,(n,u)=>{let g=x(r.groups,n),h=x(r.groups,u);if(g>h||g===h&&N(I(n,u,r))){let f=y=>{let m={};for(let E of i){let b=x(r.groups,E);b in m?m[b]=A([...m[b],E],r):m[b]=[E]}let w=[];for(let E of Object.keys(m).sort())w.push(...A(m[E],r));return L(y,i,w,e,{partitionComment:r["partition-by-comment"]})};t.report({messageId:"unexpectedObjectsOrder",data:{left:j(n.name),right:j(u.name)},node:u.node,fix:f})}})}};return{ObjectExpression:l,ObjectPattern:l}}}),ne="sort-classes",ve=v({name:ne,meta:{type:"suggestion",docs:{description:"enforce sorted classes"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},"ignore-case":{type:"boolean",default:!1},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},groups:{type:"array",default:[]}},additionalProperties:!1}],messages:{unexpectedClassesOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>({ClassBody:l=>{if(l.body.length>1){let s=C(t.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1,groups:["property","constructor","method","unknown"]}),r=t.getSourceCode(),c=l.body.map(o=>{var u;let e,{getGroup:a,defineGroup:i}=G(s.groups);o.type==="StaticBlock"?e="static":o.type==="TSIndexSignature"?e=r.text.slice(o.range.at(0),((u=o.typeAnnotation)==null?void 0:u.range.at(0))??o.range.at(1)):o.key.type==="Identifier"?{name:e}=o.key:e=r.text.slice(...o.key.range);let n=e.startsWith("_")||e.startsWith("#");if(o.type==="MethodDefinition"){o.kind==="constructor"&&i("constructor");let g=o.accessibility==="private"||n,h=o.static;g&&h&&i("static-private-method"),g&&i("private-method"),h&&i("static-method"),o.kind==="get"&&i("get-method"),o.kind==="set"&&i("set-method"),i("method")}else o.type==="TSIndexSignature"?i("index-signature"):o.type==="PropertyDefinition"&&((o.accessibility==="private"||n)&&i("private-property"),o.static&&i("static-property"),i("property"));return{size:k(o.range),group:a(),node:o,name:e}});P(c,(o,e)=>{let a=x(s.groups,o),i=x(s.groups,e);o.name!==e.name&&(a>i||a===i&&N(I(o,e,s)))&&t.report({messageId:"unexpectedClassesOrder",data:{left:j(o.name),right:j(e.name)},node:e.node,fix:n=>{let u=[],g=c.reduce((f,y)=>{let m=x(s.groups,y);return m in f?f[m]=A([...f[m],y],s):f[m]=[y],f},{}),h=Object.keys(g).sort().reduce((f,y)=>[...f,...g[y]],[]);for(let f=0,y=h.length;f<y;f++)u.push(n.replaceTextRange(M(c.at(f).node,r),r.text.slice(...M(h.at(f).node,r))));return u}})})}}})}),oe="sort-enums",ke=v({name:oe,meta:{type:"suggestion",docs:{description:"enforce sorted TypeScript enums"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},"ignore-case":{type:"boolean",default:!1},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"}},additionalProperties:!1}],messages:{unexpectedEnumsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>({TSEnumDeclaration:l=>{if(l.members.length>1&&l.members.every(({initializer:s})=>s)){let s=C(t.options.at(0),{type:p.alphabetical,order:d.asc,"ignore-case":!1}),r=t.getSourceCode(),c=l.members.map(o=>({name:o.id.type==="Literal"?`${o.id.value}`:`${r.text.slice(...o.id.range)}`,size:k(o.range),node:o}));P(c,(o,e)=>{N(I(o,e,s))&&t.report({messageId:"unexpectedEnumsOrder",data:{left:j(o.name),right:j(e.name)},node:e.node,fix:a=>L(a,c,A(c,s),r)})})}}})}),le="sort-maps",Ne=v({name:le,meta:{type:"suggestion",docs:{description:"enforce sorted Map elements"},fixable:"code",schema:[{type:"object",properties:{type:{enum:[p.alphabetical,p.natural,p["line-length"]],default:p.alphabetical,type:"string"},order:{enum:[d.asc,d.desc],default:d.asc,type:"string"},"ignore-case":{type:"boolean",default:!1}},additionalProperties:!1}],messages:{unexpectedMapElementsOrder:'Expected "{{right}}" to come before "{{left}}"'}},defaultOptions:[{type:p.alphabetical,order:d.asc}],create:t=>({NewExpression:l=>{if(l.callee.type==="Identifier"&&l.callee.name==="Map"&&l.arguments.length&&l.arguments[0].type==="ArrayExpression"){let[{elements:s}]=l.arguments;if(s.length>1){let r=C(t.options.at(0),{type:p.alphabetical,"ignore-case":!1,order:d.asc}),c=t.getSourceCode(),o=s.reduce((e,a)=>(a===null||a.type==="SpreadElement"?e.push([]):e.at(-1).push(a),e),[[]]);for(let e of o){let a=e.map(i=>{let n;if(i.type==="ArrayExpression"){let[u]=i.elements;u?u.type==="Literal"?n=u.raw:n=c.text.slice(...u.range):n=`${u}`}else n=c.text.slice(...i.range);return{size:k(i.range),node:i,name:n}});P(a,(i,n)=>{N(I(i,n,r))&&t.report({messageId:"unexpectedMapElementsOrder",data:{left:j(i.name),right:j(n.name)},node:n.node,fix:u=>L(u,a,A(a,r),c)})})}}}}})}),Ce="eslint-plugin-perfectionist";let q=t=>{let l={[se]:["error",{groups:["type",["builtin","external"],"internal-type","internal",["parent-type","sibling-type","index-type"],["parent","sibling","index"],"object","unknown"],"custom-groups":{value:{},type:{}},"newlines-between":"always","internal-pattern":["~/**"]}],[ne]:["error",{groups:["index-signature","static-property","private-property","property","constructor","static-method","private-method","method",["get-method","set-method"],"unknown"]}],[ae]:["error",{"partition-by-comment":!1}],[K]:["error",{"spread-last":!0}],[J]:["error"],[X]:["error"],[F]:["error"],[H]:["error"],[Q]:["error"],[Y]:["error"],[Z]:["error"],[ee]:["error"],[te]:["error"],[re]:["error"],[oe]:["error"],[le]:["error"]};return{rules:Object.fromEntries(Object.entries(l).map(([s,[r,c={}]])=>[`perfectionist/${s}`,[r,Object.assign(c,t)]])),plugins:["perfectionist"]}};const Pe={rules:{[K]:me,[X]:ye,[ne]:ve,[oe]:ke,[re]:Oe,[se]:Ie,[ee]:we,[te]:Ae,[le]:Ne,[H]:be,[Q]:xe,[Y]:Ee,[ae]:je,[J]:ge,[Z]:Se,[F]:he},configs:{"recommended-alphabetical":q({type:p.alphabetical,order:d.asc,"ignore-case":!1}),"recommended-natural":q({type:p.natural,order:d.asc,"ignore-case":!1}),"recommended-line-length":q({type:p["line-length"],order:d.desc})},name:Ce};module.exports=Pe;
diff --git a/dist/index.mjs b/dist/index.mjs
index f1adc19d68808b649320e54377c785b08a633422..0c1a4fec514ebbb8fdd05f0787fb1e924167c747 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -1,138 +1,143 @@
 import _ from "node:path";
-import { ESLintUtils as ue, ASTUtils as W } from "@typescript-eslint/utils";
-import { minimatch as D } from "minimatch";
-import ce from "natural-compare-lite";
-import { builtinModules as de } from "node:module";
-let j = ue.RuleCreator(
-  (r) => `https://eslint-plugin-perfectionist.azat.io/rules/${r}`
-), x = (r, l) => {
-  for (let s = 0, t = r.length; s < t; s++) {
-    let u = r[s];
-    if (l.group === u || Array.isArray(u) && typeof l.group == "string" && u.includes(l.group))
+import { ESLintUtils as ce, ASTUtils as W } from "@typescript-eslint/utils";
+import { minimatch as z } from "minimatch";
+import de from "natural-compare-lite";
+import { builtinModules as fe } from "node:module";
+let v = ce.RuleCreator(
+  (t) => `https://eslint-plugin-perfectionist.azat.io/rules/${t}`
+), x = (t, l) => {
+  for (let s = 0, r = t.length; s < r; s++) {
+    let c = t[s];
+    if (l.group === c || Array.isArray(c) && typeof l.group == "string" && c.includes(l.group))
       return s;
   }
-  return r.length;
-}, v = (r) => {
-  let [l, s] = r;
+  return t.length;
+}, k = (t) => {
+  let [l, s] = t;
   return s - l;
-}, k = (r) => r > 0;
-var p = /* @__PURE__ */ ((r) => (r.alphabetical = "alphabetical", r["line-length"] = "line-length", r.natural = "natural", r))(p || {}), d = /* @__PURE__ */ ((r) => (r.desc = "desc", r.asc = "asc", r))(d || {});
-let R = (r) => {
-  let l, s = (u) => {
-    !l && r.flat().includes(u) && (l = u);
+}, N = (t) => t > 0;
+var p = /* @__PURE__ */ ((t) => (t.alphabetical = "alphabetical", t["line-length"] = "line-length", t.natural = "natural", t))(p || {}), d = /* @__PURE__ */ ((t) => (t.desc = "desc", t.asc = "asc", t))(d || {});
+let G = (t) => {
+  let l, s = (c) => {
+    !l && t.flat().includes(c) && (l = c);
   };
   return {
     getGroup: () => l ?? "unknown",
-    setCustomGroups: (u, n) => {
-      if (u)
-        for (let [e, a] of Object.entries(u))
+    setCustomGroups: (c, o) => {
+      if (c)
+        for (let [e, a] of Object.entries(c))
           Array.isArray(a) && a.some(
-            (i) => D(n, i, {
+            (i) => z(o, i, {
               nocomment: !0
             })
-          ) && s(e), typeof a == "string" && D(n, a, {
+          ) && s(e), typeof a == "string" && z(o, a, {
             nocomment: !0
           }) && s(e);
     },
     defineGroup: s
   };
-}, O = (r, l, s) => {
+}, I = (t, l, s) => {
   var e, a;
-  if ((e = l.dependencies) != null && e.includes(r.name))
+  if ((e = l.dependencies) != null && e.includes(t.name))
     return -1;
-  if ((a = r.dependencies) != null && a.includes(l.name))
+  if ((a = t.dependencies) != null && a.includes(l.name))
     return 1;
-  let t = s.order === "asc" ? 1 : -1, u, n = (i) => s["ignore-case"] ? i.toLowerCase() : i;
-  return s.type === p.alphabetical ? u = (i, o) => n(i.name).localeCompare(n(o.name)) : s.type === p.natural ? u = (i, o) => ce(n(i.name), n(o.name)) : u = (i, o) => {
-    let c = i.size, y = o.size, h = s["max-line-length"];
-    if (h) {
-      let f = (g, m) => g > h && m.hasMultipleImportDeclarations;
-      f(c, i) && (c = i.name.length + 10), f(y, o) && (y = o.name.length + 10);
+  let r = s.order === "asc" ? 1 : -1, c, o = (i) => s["ignore-case"] ? i.toLowerCase() : i;
+  return s.type === p.alphabetical ? c = (i, n) => o(i.name).localeCompare(o(n.name)) : s.type === p.natural ? c = (i, n) => de(o(i.name), o(n.name)) : c = (i, n) => {
+    let u = i.size, g = n.size, h = s["max-line-length"];
+    if (i.sortRule === "sort-import" && i.text && (u = pe(i.text)), n.sortRule === "sort-import" && n.text && (g = pe(n.text)), h) {
+      let f = (y, m) => y > h && m.hasMultipleImportDeclarations;
+      f(u, i) && !t.text && (u = i.name.length + 10), f(g, n) && !l.text && (g = n.name.length + 10), i.sortRule === "sort-import" && i.text && f(i.text.length, i) && (u = u / 10), n.sortRule === "sort-import" && n.text && f(n.text.length, n) && (g = g / 10);
     }
-    return c - y;
-  }, t * u(r, l);
-}, A = (r, l) => [...r].sort((s, t) => O(s, t, l)), fe = (r, l) => {
-  let s = l.getTokenAfter(r, {
-    filter: ({ value: t, type: u }) => !(u === "Punctuator" && [",", ";"].includes(t)),
+    return u - g;
+  }, r * c(t, l);
+};
+const pe = (t) => {
+  const l = t.split("from").at(0).length * 1e3;
+  return t.split("import * as").length > 1 ? l / 100 : t.split("import {").length === 1 ? l / 10 : l;
+};
+let A = (t, l) => [...t].sort((s, r) => I(s, r, l)), ge = (t, l) => {
+  let s = l.getTokenAfter(t, {
+    filter: ({ value: r, type: c }) => !(c === "Punctuator" && [",", ";"].includes(r)),
     includeComments: !0
   });
-  return ((s == null ? void 0 : s.type) === "Block" || (s == null ? void 0 : s.type) === "Line") && r.loc.end.line === s.loc.end.line ? s : null;
-}, pe = (r, l) => Array.isArray(r) && r.some(
-  (s) => D(l.trim(), s, {
+  return ((s == null ? void 0 : s.type) === "Block" || (s == null ? void 0 : s.type) === "Line") && t.loc.end.line === s.loc.end.line ? s : null;
+}, ue = (t, l) => Array.isArray(t) && t.some(
+  (s) => z(l.trim(), s, {
     nocomment: !0
   })
-) || typeof r == "string" && D(l.trim(), r, {
+) || typeof t == "string" && z(l.trim(), t, {
   nocomment: !0
-}) || r === !0, J = (r, l) => {
-  let [s, t] = l.getTokensBefore(r, {
-    filter: ({ value: u, type: n }) => !(n === "Punctuator" && [",", ";"].includes(u)),
+}) || t === !0, J = (t, l) => {
+  let [s, r] = l.getTokensBefore(t, {
+    filter: ({ value: c, type: o }) => !(o === "Punctuator" && [",", ";"].includes(c)),
     includeComments: !0,
     count: 2
   });
-  return ((t == null ? void 0 : t.type) === "Block" || (t == null ? void 0 : t.type) === "Line") && r.loc.start.line - t.loc.end.line <= 1 && (s == null ? void 0 : s.loc.end.line) !== t.loc.start.line ? t : null;
-}, M = (r, l, s) => {
+  return ((r == null ? void 0 : r.type) === "Block" || (r == null ? void 0 : r.type) === "Line") && t.loc.start.line - r.loc.end.line <= 1 && (s == null ? void 0 : s.loc.end.line) !== r.loc.start.line ? r : null;
+}, M = (t, l, s) => {
   var a;
-  let t = r.range.at(0), u = r.range.at(1), n = l.text.slice(t, u);
-  if (W.isParenthesized(r, l)) {
+  let r = t.range.at(0), c = t.range.at(1), o = l.text.slice(r, c);
+  if (W.isParenthesized(t, l)) {
     let i = l.getTokenBefore(
-      r,
+      t,
       W.isOpeningParenToken
-    ), o = l.getTokenAfter(
-      r,
+    ), n = l.getTokenAfter(
+      t,
       W.isClosingParenToken
     );
-    t = i.range.at(0), u = o.range.at(1);
+    r = i.range.at(0), c = n.range.at(1);
   }
-  let e = J(r, l);
-  if (n.endsWith(";") || n.endsWith(",")) {
-    let i = l.getTokensAfter(r, {
+  let e = J(t, l);
+  if (o.endsWith(";") || o.endsWith(",")) {
+    let i = l.getTokensAfter(t, {
       includeComments: !0,
       count: 2
     });
-    r.loc.start.line === ((a = i.at(1)) == null ? void 0 : a.loc.start.line) && (u -= 1);
+    t.loc.start.line === ((a = i.at(1)) == null ? void 0 : a.loc.start.line) && (c -= 1);
   }
-  return e && !pe(
+  return e && !ue(
     (s == null ? void 0 : s.partitionComment) ?? !1,
     e.value
-  ) && (t = e.range.at(0)), [t, u];
-}, T = (r, l, s, t, u) => {
+  ) && (r = e.range.at(0)), [r, c];
+}, L = (t, l, s, r, c) => {
   var a, i;
-  let n = [], e = ((a = l.at(0)) == null ? void 0 : a.node.loc.start.line) === ((i = l.at(-1)) == null ? void 0 : i.node.loc.end.line);
-  for (let o = 0, c = l.length; o < c; o++) {
-    let { node: y } = l.at(o);
-    n.push(
-      r.replaceTextRange(
-        M(y, t, u),
-        t.text.slice(
-          ...M(s.at(o).node, t, u)
+  let o = [], e = ((a = l.at(0)) == null ? void 0 : a.node.loc.start.line) === ((i = l.at(-1)) == null ? void 0 : i.node.loc.end.line);
+  for (let n = 0, u = l.length; n < u; n++) {
+    let { node: g } = l.at(n);
+    o.push(
+      t.replaceTextRange(
+        M(g, r, c),
+        r.text.slice(
+          ...M(s.at(n).node, r, c)
         )
       )
     );
-    let h = fe(s.at(o).node, t);
+    let h = ge(s.at(n).node, r);
     if (h && !e) {
-      let g = [
-        t.getTokenBefore(h).range.at(1),
+      let y = [
+        r.getTokenBefore(h).range.at(1),
         h.range.at(1)
       ];
-      n.push(r.replaceTextRange(g, ""));
-      let m = t.getTokenAfter(y);
-      n.push(
-        r.insertTextAfter(
-          (m == null ? void 0 : m.loc.end.line) === y.loc.end.line ? m : y,
-          t.text.slice(...g)
+      o.push(t.replaceTextRange(y, ""));
+      let m = r.getTokenAfter(g);
+      o.push(
+        t.insertTextAfter(
+          (m == null ? void 0 : m.loc.end.line) === g.loc.end.line ? m : g,
+          r.text.slice(...y)
         )
       );
     }
   }
-  return n;
-}, C = (r = {}, l) => Object.assign(l, r), P = (r, l) => {
-  if (r.length > 1)
-    for (let s = 1; s < r.length; s++) {
-      let t = r.at(s - 1), u = r.at(s);
-      t && u && l(t, u, s - 1);
+  return o;
+}, C = (t = {}, l) => Object.assign(l, t), P = (t, l) => {
+  if (t.length > 1)
+    for (let s = 1; s < t.length; s++) {
+      let r = t.at(s - 1), c = t.at(s);
+      r && c && l(r, c, s - 1);
     }
 };
-const X = "sort-svelte-attributes", ge = j({
+const X = "sort-svelte-attributes", ye = v({
   name: X,
   meta: {
     type: "suggestion",
@@ -182,61 +187,61 @@ const X = "sort-svelte-attributes", ge = j({
       order: d.asc
     }
   ],
-  create: (r) => _.extname(r.getFilename()) !== ".svelte" ? {} : {
+  create: (t) => _.extname(t.getFilename()) !== ".svelte" ? {} : {
     SvelteStartTag: (l) => {
       if (l.attributes.length > 1) {
-        let s = C(r.options.at(0), {
+        let s = C(t.options.at(0), {
           type: p.alphabetical,
           order: d.asc,
           "ignore-case": !1,
           "custom-groups": {},
           groups: []
-        }), t = r.getSourceCode(), u = l.attributes.reduce(
-          (n, e) => {
+        }), r = t.getSourceCode(), c = l.attributes.reduce(
+          (o, e) => {
             if (e.type === "SvelteSpreadAttribute")
-              return n.push([]), n;
-            let a, { getGroup: i, defineGroup: o, setCustomGroups: c } = R(
+              return o.push([]), o;
+            let a, { getGroup: i, defineGroup: n, setCustomGroups: u } = G(
               s.groups
             );
-            return e.key.type === "SvelteSpecialDirectiveKey" ? a = t.text.slice(...e.key.range) : typeof e.key.name == "string" ? { name: a } = e.key : a = t.text.slice(...e.key.range), c(s["custom-groups"], a), e.type === "SvelteShorthandAttribute" && (o("svelte-shorthand"), o("shorthand")), (!("value" in e) || Array.isArray(e.value) && !e.value.at(0)) && o("shorthand"), e.loc.start.line !== e.loc.end.line && o("multiline"), n.at(-1).push({
-              size: v(e.range),
+            return e.key.type === "SvelteSpecialDirectiveKey" ? a = r.text.slice(...e.key.range) : typeof e.key.name == "string" ? { name: a } = e.key : a = r.text.slice(...e.key.range), u(s["custom-groups"], a), e.type === "SvelteShorthandAttribute" && (n("svelte-shorthand"), n("shorthand")), (!("value" in e) || Array.isArray(e.value) && !e.value.at(0)) && n("shorthand"), e.loc.start.line !== e.loc.end.line && n("multiline"), o.at(-1).push({
+              size: k(e.range),
               node: e,
               group: i(),
               name: a
-            }), n;
+            }), o;
           },
           [[]]
         );
-        for (let n of u)
-          P(n, (e, a) => {
-            let i = x(s.groups, e), o = x(s.groups, a);
-            (i > o || i === o && k(O(e, a, s))) && r.report({
+        for (let o of c)
+          P(o, (e, a) => {
+            let i = x(s.groups, e), n = x(s.groups, a);
+            (i > n || i === n && N(I(e, a, s))) && t.report({
               messageId: "unexpectedSvelteAttributesOrder",
               data: {
                 left: e.name,
                 right: a.name
               },
               node: a.node,
-              fix: (c) => {
-                let y = {};
-                for (let f of n) {
-                  let g = x(s.groups, f);
-                  g in y ? y[g] = A(
-                    [...y[g], f],
+              fix: (u) => {
+                let g = {};
+                for (let f of o) {
+                  let y = x(s.groups, f);
+                  y in g ? g[y] = A(
+                    [...g[y], f],
                     s
-                  ) : y[g] = [f];
+                  ) : g[y] = [f];
                 }
                 let h = [];
-                for (let f of Object.keys(y).sort())
-                  h.push(...A(y[f], s));
-                return T(c, n, h, t);
+                for (let f of Object.keys(g).sort())
+                  h.push(...A(g[f], s));
+                return L(u, o, h, r);
               }
             });
           });
       }
     }
   }
-}), q = "sort-astro-attributes", ye = j({
+}), q = "sort-astro-attributes", me = v({
   name: q,
   meta: {
     type: "suggestion",
@@ -287,55 +292,55 @@ const X = "sort-svelte-attributes", ge = j({
     }
   ],
   // @ts-ignore
-  create: (r) => _.extname(r.getFilename()) !== ".astro" ? {} : {
+  create: (t) => _.extname(t.getFilename()) !== ".astro" ? {} : {
     JSXElement: (l) => {
       let { attributes: s } = l.openingElement;
       if (s.length > 1) {
-        let t = C(r.options.at(0), {
+        let r = C(t.options.at(0), {
           type: p.alphabetical,
           order: d.asc,
           "ignore-case": !1,
           "custom-groups": {},
           groups: []
-        }), u = r.getSourceCode(), n = s.reduce(
+        }), c = t.getSourceCode(), o = s.reduce(
           (e, a) => {
             if (a.type === "JSXSpreadAttribute")
               return e.push([]), e;
-            let i = typeof a.name.name == "string" ? a.name.name : u.text.slice(...a.name.range), { getGroup: o, defineGroup: c, setCustomGroups: y } = R(
-              t.groups
+            let i = typeof a.name.name == "string" ? a.name.name : c.text.slice(...a.name.range), { getGroup: n, defineGroup: u, setCustomGroups: g } = G(
+              r.groups
             );
-            return y(t["custom-groups"], i), a.type === "AstroShorthandAttribute" && (c("astro-shorthand"), c("shorthand")), a.value === null && c("shorthand"), a.loc.start.line !== a.loc.end.line && c("multiline"), e.at(-1).push({
-              size: v(a.range),
+            return g(r["custom-groups"], i), a.type === "AstroShorthandAttribute" && (u("astro-shorthand"), u("shorthand")), a.value === null && u("shorthand"), a.loc.start.line !== a.loc.end.line && u("multiline"), e.at(-1).push({
+              size: k(a.range),
               node: a,
-              group: o(),
+              group: n(),
               name: i
             }), e;
           },
           [[]]
         );
-        for (let e of n)
+        for (let e of o)
           P(e, (a, i) => {
-            let o = x(t.groups, a), c = x(t.groups, i);
-            (o > c || o === c && k(O(a, i, t))) && r.report({
+            let n = x(r.groups, a), u = x(r.groups, i);
+            (n > u || n === u && N(I(a, i, r))) && t.report({
               messageId: "unexpectedAstroAttributesOrder",
               data: {
                 left: a.name,
                 right: i.name
               },
               node: i.node,
-              fix: (y) => {
+              fix: (g) => {
                 let h = {};
-                for (let g of e) {
-                  let m = x(t.groups, g);
+                for (let y of e) {
+                  let m = x(r.groups, y);
                   m in h ? h[m] = A(
-                    [...h[m], g],
-                    t
-                  ) : h[m] = [g];
+                    [...h[m], y],
+                    r
+                  ) : h[m] = [y];
                 }
                 let f = [];
-                for (let g of Object.keys(h).sort())
-                  f.push(...A(h[g], t));
-                return T(y, e, f, u);
+                for (let y of Object.keys(h).sort())
+                  f.push(...A(h[y], r));
+                return L(g, e, f, c);
               }
             });
           });
@@ -343,8 +348,8 @@ const X = "sort-svelte-attributes", ge = j({
     }
   }
 });
-let I = (r) => r.replaceAll(/\s\s+/g, " ").trim();
-const K = "sort-array-includes", me = j({
+let j = (t) => t.replaceAll(/\s\s+/g, " ").trim();
+const K = "sort-array-includes", he = v({
   name: K,
   meta: {
     type: "suggestion",
@@ -392,40 +397,40 @@ const K = "sort-array-includes", me = j({
       order: d.asc
     }
   ],
-  create: (r) => ({
+  create: (t) => ({
     MemberExpression: (l) => {
       if ((l.object.type === "ArrayExpression" || l.object.type === "NewExpression") && l.property.type === "Identifier" && l.property.name === "includes") {
         let s = l.object.type === "ArrayExpression" ? l.object.elements : l.object.arguments;
         if (s.length > 1) {
-          let t = C(r.options.at(0), {
+          let r = C(t.options.at(0), {
             type: p.alphabetical,
             order: d.asc,
             "ignore-case": !1,
             "spread-last": !1
-          }), u = r.getSourceCode(), n = s.reduce(
+          }), c = t.getSourceCode(), o = s.reduce(
             (e, a) => (a !== null && e.at(0).push({
-              name: a.type === "Literal" ? `${a.value}` : u.text.slice(...a.range),
-              size: v(a.range),
+              name: a.type === "Literal" ? `${a.value}` : c.text.slice(...a.range),
+              size: k(a.range),
               type: a.type,
               node: a
             }), e),
             [[], []]
           ).flat();
-          P(n, (e, a) => {
+          P(o, (e, a) => {
             let i;
-            t["spread-last"] && e.node.type === "Literal" && a.node.type === "SpreadElement" ? i = !1 : t["spread-last"] && e.node.type === "SpreadElement" && a.node.type === "Literal" ? i = !0 : i = k(O(e, a, t)), i && r.report({
+            r["spread-last"] && e.node.type === "Literal" && a.node.type === "SpreadElement" ? i = !1 : r["spread-last"] && e.node.type === "SpreadElement" && a.node.type === "Literal" ? i = !0 : i = N(I(e, a, r)), i && t.report({
               messageId: "unexpectedArrayIncludesOrder",
               data: {
-                left: I(e.name),
-                right: I(a.name)
+                left: j(e.name),
+                right: j(a.name)
               },
               node: a.node,
-              fix: (o) => {
-                let c = A(n, t);
-                if (t["spread-last"])
-                  for (let y = 0, h = c.length; y < h; y++)
-                    c.at(y).node.type === "SpreadElement" && c.push(c.splice(y, 1).at(0));
-                return T(o, n, c, u);
+              fix: (n) => {
+                let u = A(o, r);
+                if (r["spread-last"])
+                  for (let g = 0, h = u.length; g < h; g++)
+                    u.at(g).node.type === "SpreadElement" && u.push(u.splice(g, 1).at(0));
+                return L(n, o, u, c);
               }
             });
           });
@@ -433,7 +438,7 @@ const K = "sort-array-includes", me = j({
       }
     }
   })
-}), F = "sort-vue-attributes", he = j({
+}), F = "sort-vue-attributes", be = v({
   name: F,
   meta: {
     type: "suggestion",
@@ -484,60 +489,60 @@ const K = "sort-array-includes", me = j({
       order: d.asc
     }
   ],
-  create: (r) => {
-    if (_.extname(r.getFilename()) !== ".vue")
+  create: (t) => {
+    if (_.extname(t.getFilename()) !== ".vue")
       return {};
-    if (!("defineTemplateBodyVisitor" in r.parserServices))
+    if (!("defineTemplateBodyVisitor" in t.parserServices))
       return {};
-    let { defineTemplateBodyVisitor: l } = r.parserServices;
+    let { defineTemplateBodyVisitor: l } = t.parserServices;
     return l({
       VStartTag: (s) => {
         if (s.attributes.length > 1) {
-          let t = C(r.options.at(0), {
+          let r = C(t.options.at(0), {
             type: p.alphabetical,
             order: d.asc,
             "ignore-case": !1,
             "custom-groups": {},
             groups: []
-          }), u = r.getSourceCode(), n = s.attributes.reduce(
+          }), c = t.getSourceCode(), o = s.attributes.reduce(
             (e, a) => {
               if (a.key.type === "VDirectiveKey" && a.key.name.rawName === "bind")
                 return e.push([]), e;
-              let i, { getGroup: o, defineGroup: c, setCustomGroups: y } = R(
-                t.groups
+              let i, { getGroup: n, defineGroup: u, setCustomGroups: g } = G(
+                r.groups
               );
-              return typeof a.key.name == "string" && a.key.type !== "VDirectiveKey" ? i = a.key.rawName : i = u.text.slice(...a.key.range), y(t["custom-groups"], i), a.value === null && c("shorthand"), a.loc.start.line !== a.loc.end.line && c("multiline"), e.at(-1).push({
-                size: v(a.range),
+              return typeof a.key.name == "string" && a.key.type !== "VDirectiveKey" ? i = a.key.rawName : i = c.text.slice(...a.key.range), g(r["custom-groups"], i), a.value === null && u("shorthand"), a.loc.start.line !== a.loc.end.line && u("multiline"), e.at(-1).push({
+                size: k(a.range),
                 node: a,
-                group: o(),
+                group: n(),
                 name: i
               }), e;
             },
             [[]]
           );
-          for (let e of n)
+          for (let e of o)
             P(e, (a, i) => {
-              let o = x(t.groups, a), c = x(t.groups, i);
-              (o > c || o === c && k(O(a, i, t))) && r.report({
+              let n = x(r.groups, a), u = x(r.groups, i);
+              (n > u || n === u && N(I(a, i, r))) && t.report({
                 messageId: "unexpectedVueAttributesOrder",
                 data: {
                   left: a.name,
                   right: i.name
                 },
                 node: i.node,
-                fix: (y) => {
+                fix: (g) => {
                   let h = {};
-                  for (let g of e) {
-                    let m = x(t.groups, g);
+                  for (let y of e) {
+                    let m = x(r.groups, y);
                     m in h ? h[m] = A(
-                      [...h[m], g],
-                      t
-                    ) : h[m] = [g];
+                      [...h[m], y],
+                      r
+                    ) : h[m] = [y];
                   }
                   let f = [];
-                  for (let g of Object.keys(h).sort())
-                    f.push(...A(h[g], t));
-                  return T(y, e, f, u);
+                  for (let y of Object.keys(h).sort())
+                    f.push(...A(h[y], r));
+                  return L(g, e, f, c);
                 }
               });
             });
@@ -545,7 +550,7 @@ const K = "sort-array-includes", me = j({
       }
     });
   }
-}), H = "sort-named-exports", be = j({
+}), H = "sort-named-exports", xe = v({
   name: H,
   meta: {
     type: "suggestion",
@@ -589,33 +594,33 @@ const K = "sort-array-includes", me = j({
       order: d.asc
     }
   ],
-  create: (r) => ({
+  create: (t) => ({
     ExportNamedDeclaration: (l) => {
       if (l.specifiers.length > 1) {
-        let s = C(r.options.at(0), {
+        let s = C(t.options.at(0), {
           type: p.alphabetical,
           "ignore-case": !1,
           order: d.asc
-        }), t = r.getSourceCode(), u = l.specifiers.map((n) => ({
-          size: v(n.range),
-          name: n.local.name,
-          node: n
+        }), r = t.getSourceCode(), c = l.specifiers.map((o) => ({
+          size: k(o.range),
+          name: o.local.name,
+          node: o
         }));
-        P(u, (n, e) => {
-          k(O(n, e, s)) && r.report({
+        P(c, (o, e) => {
+          N(I(o, e, s)) && t.report({
             messageId: "unexpectedNamedExportsOrder",
             data: {
-              left: n.name,
+              left: o.name,
               right: e.name
             },
             node: e.node,
-            fix: (a) => T(a, u, A(u, s), t)
+            fix: (a) => L(a, c, A(c, s), r)
           });
         });
       }
     }
   })
-}), Q = "sort-named-imports", xe = j({
+}), Q = "sort-named-imports", Ee = v({
   name: Q,
   meta: {
     type: "suggestion",
@@ -663,45 +668,45 @@ const K = "sort-array-includes", me = j({
       order: d.asc
     }
   ],
-  create: (r) => ({
+  create: (t) => ({
     ImportDeclaration: (l) => {
       let s = l.specifiers.filter(
-        ({ type: t }) => t === "ImportSpecifier"
+        ({ type: r }) => r === "ImportSpecifier"
       );
       if (s.length > 1) {
-        let t = C(r.options.at(0), {
+        let r = C(t.options.at(0), {
           type: p.alphabetical,
           "ignore-alias": !0,
           "ignore-case": !1,
           order: d.asc
-        }), u = r.getSourceCode(), n = s.map((e) => {
+        }), c = t.getSourceCode(), o = s.map((e) => {
           let { name: a } = e.local;
-          return t["ignore-alias"] && e.type === "ImportSpecifier" && ({ name: a } = e.imported), {
-            size: v(e.range),
+          return r["ignore-alias"] && e.type === "ImportSpecifier" && ({ name: a } = e.imported), {
+            size: k(e.range),
             node: e,
             name: a
           };
         });
-        P(n, (e, a) => {
-          k(O(e, a, t)) && r.report({
+        P(o, (e, a) => {
+          N(I(e, a, r)) && t.report({
             messageId: "unexpectedNamedImportsOrder",
             data: {
               left: e.name,
               right: a.name
             },
             node: a.node,
-            fix: (i) => T(i, n, A(n, t), u)
+            fix: (i) => L(i, o, A(o, r), c)
           });
         });
       }
     }
   })
 });
-let B = (r, l, s) => r.lines.slice(
+let B = (t, l, s) => t.lines.slice(
   l.node.loc.end.line,
   s.node.loc.start.line - 1
-).filter((u) => !u.trim().length).length;
-const Y = "sort-object-types", Ee = j({
+).filter((c) => !c.trim().length).length;
+const Y = "sort-object-types", Se = v({
   name: Y,
   meta: {
     type: "suggestion",
@@ -756,77 +761,77 @@ const Y = "sort-object-types", Ee = j({
       order: d.asc
     }
   ],
-  create: (r) => ({
+  create: (t) => ({
     TSTypeLiteral: (l) => {
       if (l.members.length > 1) {
-        let s = C(r.options.at(0), {
+        let s = C(t.options.at(0), {
           "partition-by-new-line": !1,
           type: p.alphabetical,
           "ignore-case": !1,
           order: d.asc,
           "custom-groups": {},
           groups: []
-        }), t = r.getSourceCode(), u = l.members.reduce(
-          (n, e) => {
-            var E, b, N, S;
-            let a, i = t.text.slice(e.range.at(0), e.range.at(1)), o = (E = n.at(-1)) == null ? void 0 : E.at(-1), { getGroup: c, defineGroup: y, setCustomGroups: h } = R(
+        }), r = t.getSourceCode(), c = l.members.reduce(
+          (o, e) => {
+            var E, b, O, S;
+            let a, i = r.text.slice(e.range.at(0), e.range.at(1)), n = (E = o.at(-1)) == null ? void 0 : E.at(-1), { getGroup: u, defineGroup: g, setCustomGroups: h } = G(
               s.groups
-            ), f = (L) => L.replace(/(,|;)$/, "");
+            ), f = (T) => T.replace(/(,|;)$/, "");
             if (e.type === "TSPropertySignature")
-              e.key.type === "Identifier" ? { name: a } = e.key : e.key.type === "Literal" ? a = `${e.key.value}` : a = t.text.slice(
+              e.key.type === "Identifier" ? { name: a } = e.key : e.key.type === "Literal" ? a = `${e.key.value}` : a = r.text.slice(
                 e.range.at(0),
                 (b = e.typeAnnotation) == null ? void 0 : b.range.at(0)
               );
             else if (e.type === "TSIndexSignature") {
-              let L = ((N = e.typeAnnotation) == null ? void 0 : N.range.at(0)) ?? e.range.at(1);
-              a = f(t.text.slice(e.range.at(0), L));
+              let T = ((O = e.typeAnnotation) == null ? void 0 : O.range.at(0)) ?? e.range.at(1);
+              a = f(r.text.slice(e.range.at(0), T));
             } else
               a = f(
-                t.text.slice(e.range.at(0), e.range.at(1))
+                r.text.slice(e.range.at(0), e.range.at(1))
               );
-            h(s["custom-groups"], a), e.loc.start.line !== e.loc.end.line && y("multiline");
+            h(s["custom-groups"], a), e.loc.start.line !== e.loc.end.line && g("multiline");
             let m = i.endsWith(";") || i.endsWith(",") ? 1 : 0, w = {
-              size: v(e.range) - m,
+              size: k(e.range) - m,
               node: e,
               name: a
             };
-            return s["partition-by-new-line"] && o && B(t, o, w) && n.push([]), (S = n.at(-1)) == null || S.push({
+            return s["partition-by-new-line"] && n && B(r, n, w) && o.push([]), (S = o.at(-1)) == null || S.push({
               ...w,
-              group: c()
-            }), n;
+              group: u()
+            }), o;
           },
           [[]]
         );
-        for (let n of u)
-          P(n, (e, a) => {
-            let i = x(s.groups, e), o = x(s.groups, a);
-            (i > o || i === o && k(O(e, a, s))) && r.report({
+        for (let o of c)
+          P(o, (e, a) => {
+            let i = x(s.groups, e), n = x(s.groups, a);
+            (i > n || i === n && N(I(e, a, s))) && t.report({
               messageId: "unexpectedObjectTypesOrder",
               data: {
-                left: I(e.name),
-                right: I(a.name)
+                left: j(e.name),
+                right: j(a.name)
               },
               node: a.node,
-              fix: (c) => {
-                let y = {};
-                for (let f of n) {
-                  let g = x(s.groups, f);
-                  g in y ? y[g] = A(
-                    [...y[g], f],
+              fix: (u) => {
+                let g = {};
+                for (let f of o) {
+                  let y = x(s.groups, f);
+                  y in g ? g[y] = A(
+                    [...g[y], f],
                     s
-                  ) : y[g] = [f];
+                  ) : g[y] = [f];
                 }
                 let h = [];
-                for (let f of Object.keys(y).sort())
-                  h.push(...A(y[f], s));
-                return T(c, n, h, t);
+                for (let f of Object.keys(g).sort())
+                  h.push(...A(g[f], s));
+                return L(u, o, h, r);
               }
             });
           });
       }
     }
   })
-}), Z = "sort-union-types", Se = j({
+}), Z = "sort-union-types", we = v({
   name: Z,
   meta: {
     type: "suggestion",
@@ -874,45 +879,45 @@ const Y = "sort-object-types", Ee = j({
       order: d.asc
     }
   ],
-  create: (r) => ({
+  create: (t) => ({
     TSUnionType: (l) => {
-      let s = r.getSourceCode(), t = C(r.options.at(0), {
+      let s = t.getSourceCode(), r = C(t.options.at(0), {
         type: p.alphabetical,
         "nullable-last": !1,
         "ignore-case": !1,
         order: d.asc
-      }), u = l.types.map((n) => ({
-        group: n.type === "TSNullKeyword" || n.type === "TSUndefinedKeyword" ? "nullable" : "unknown",
-        name: s.text.slice(...n.range),
-        size: v(n.range),
-        node: n
+      }), c = l.types.map((o) => ({
+        group: o.type === "TSNullKeyword" || o.type === "TSUndefinedKeyword" ? "nullable" : "unknown",
+        name: s.text.slice(...o.range),
+        size: k(o.range),
+        node: o
       }));
-      P(u, (n, e) => {
-        let a = k(O(n, e, t));
-        t["nullable-last"] && (n.group === "nullable" && e.group === "unknown" ? a = !0 : n.group === "unknown" && e.group === "nullable" && (a = !1)), a && r.report({
+      P(c, (o, e) => {
+        let a = N(I(o, e, r));
+        r["nullable-last"] && (o.group === "nullable" && e.group === "unknown" ? a = !0 : o.group === "unknown" && e.group === "nullable" && (a = !1)), a && t.report({
           messageId: "unexpectedUnionTypesOrder",
           data: {
-            left: I(n.name),
-            right: I(e.name)
+            left: j(o.name),
+            right: j(e.name)
           },
           node: e.node,
           fix: (i) => {
-            let o = [];
-            if (t["nullable-last"]) {
-              let c = [], y = u.filter((h) => h.group === "nullable" ? (c.push(h), !1) : !0);
-              o = [
-                ...A(y, t),
-                ...A(c, t)
+            let n = [];
+            if (r["nullable-last"]) {
+              let u = [], g = c.filter((h) => h.group === "nullable" ? (u.push(h), !1) : !0);
+              n = [
+                ...A(g, r),
+                ...A(u, r)
               ];
             } else
-              o = A(u, t);
-            return T(i, u, o, s);
+              n = A(c, r);
+            return L(i, c, n, s);
           }
         });
       });
     }
   })
-}), ee = "sort-interfaces", we = j({
+}), ee = "sort-interfaces", Ae = v({
   name: ee,
   meta: {
     type: "suggestion",
@@ -973,10 +978,10 @@ const Y = "sort-object-types", Ee = j({
       order: d.asc
     }
   ],
-  create: (r) => ({
+  create: (t) => ({
     TSInterfaceDeclaration: (l) => {
       if (l.body.body.length > 1) {
-        let s = C(r.options.at(0), {
+        let s = C(t.options.at(0), {
           "partition-by-new-line": !1,
           type: p.alphabetical,
           "ignore-case": !1,
@@ -986,16 +991,16 @@ const Y = "sort-object-types", Ee = j({
           groups: []
         });
         if (!s["ignore-pattern"].some(
-          (t) => D(l.id.name, t, {
+          (r) => z(l.id.name, r, {
             nocomment: !0
           })
         )) {
-          let t = r.getSourceCode(), u = l.body.body.reduce(
-            (n, e) => {
-              var f, g, m, w;
+          let r = t.getSourceCode(), c = l.body.body.reduce(
+            (o, e) => {
+              var f, y, m, w;
               if (e.type === "TSCallSignatureDeclaration")
-                return n.push([]), n;
-              let a = (f = n.at(-1)) == null ? void 0 : f.at(-1), i, { getGroup: o, defineGroup: c, setCustomGroups: y } = R(
+                return o.push([]), o;
+              let a = (f = o.at(-1)) == null ? void 0 : f.at(-1), i, { getGroup: n, defineGroup: u, setCustomGroups: g } = G(
                 s.groups
               );
               if (e.type === "TSPropertySignature")
@@ -1004,51 +1009,51 @@ const Y = "sort-object-types", Ee = j({
                 else if (e.key.type === "Literal")
                   i = `${e.key.value}`;
                 else {
-                  let E = ((g = e.typeAnnotation) == null ? void 0 : g.range.at(0)) ?? e.range.at(1) - (e.optional ? 1 : 0);
-                  i = t.text.slice(e.range.at(0), E);
+                  let E = ((y = e.typeAnnotation) == null ? void 0 : y.range.at(0)) ?? e.range.at(1) - (e.optional ? 1 : 0);
+                  i = r.text.slice(e.range.at(0), E);
                 }
               else if (e.type === "TSIndexSignature") {
                 let E = ((m = e.typeAnnotation) == null ? void 0 : m.range.at(0)) ?? e.range.at(1);
-                i = t.text.slice(e.range.at(0), E);
+                i = r.text.slice(e.range.at(0), E);
               } else {
                 let E = ((w = e.returnType) == null ? void 0 : w.range.at(0)) ?? e.range.at(1);
-                i = t.text.slice(e.range.at(0), E);
+                i = r.text.slice(e.range.at(0), E);
               }
               let h = {
-                size: v(e.range),
+                size: k(e.range),
                 node: e,
                 name: i
               };
-              return s["partition-by-new-line"] && a && B(t, a, h) && n.push([]), y(s["custom-groups"], i), e.loc.start.line !== e.loc.end.line && c("multiline"), n.at(-1).push({
+              return s["partition-by-new-line"] && a && B(r, a, h) && o.push([]), g(s["custom-groups"], i), e.loc.start.line !== e.loc.end.line && u("multiline"), o.at(-1).push({
                 ...h,
-                group: o()
-              }), n;
+                group: n()
+              }), o;
             },
             [[]]
           );
-          for (let n of u)
-            P(n, (e, a) => {
-              let i = x(s.groups, e), o = x(s.groups, a);
-              (i > o || i === o && k(O(e, a, s))) && r.report({
+          for (let o of c)
+            P(o, (e, a) => {
+              let i = x(s.groups, e), n = x(s.groups, a);
+              (i > n || i === n && N(I(e, a, s))) && t.report({
                 messageId: "unexpectedInterfacePropertiesOrder",
                 data: {
-                  left: I(e.name),
-                  right: I(a.name)
+                  left: j(e.name),
+                  right: j(a.name)
                 },
                 node: a.node,
-                fix: (c) => {
-                  let y = {};
-                  for (let f of n) {
-                    let g = x(s.groups, f);
-                    g in y ? y[g] = A(
-                      [...y[g], f],
+                fix: (u) => {
+                  let g = {};
+                  for (let f of o) {
+                    let y = x(s.groups, f);
+                    y in g ? g[y] = A(
+                      [...g[y], f],
                       s
-                    ) : y[g] = [f];
+                    ) : g[y] = [f];
                   }
                   let h = [];
-                  for (let f of Object.keys(y).sort())
-                    h.push(...A(y[f], s));
-                  return T(c, n, h, t);
+                  for (let f of Object.keys(g).sort())
+                    h.push(...A(g[f], s));
+                  return L(u, o, h, r);
                 }
               });
             });
@@ -1056,7 +1061,7 @@ const Y = "sort-object-types", Ee = j({
       }
     }
   })
-}), te = "sort-jsx-props", Ae = j({
+}), te = "sort-jsx-props", Oe = v({
   name: te,
   meta: {
     type: "suggestion",
@@ -1106,65 +1111,65 @@ const Y = "sort-object-types", Ee = j({
       order: d.asc
     }
   ],
-  create: (r) => [".svelte", ".astro", ".vue"].includes(
-    _.extname(r.getFilename())
+  create: (t) => [".svelte", ".astro", ".vue"].includes(
+    _.extname(t.getFilename())
   ) ? {} : {
     JSXElement: (l) => {
       if (l.openingElement.attributes.length > 1) {
-        let s = C(r.options.at(0), {
+        let s = C(t.options.at(0), {
           type: p.alphabetical,
           "ignore-case": !1,
           order: d.asc,
           "custom-groups": {},
           groups: []
-        }), t = r.getSourceCode(), u = l.openingElement.attributes.reduce(
-          (n, e) => {
+        }), r = t.getSourceCode(), c = l.openingElement.attributes.reduce(
+          (o, e) => {
             if (e.type === "JSXSpreadAttribute")
-              return n.push([]), n;
-            let a = e.name.type === "JSXNamespacedName" ? `${e.name.namespace.name}:${e.name.name.name}` : e.name.name, { getGroup: i, defineGroup: o, setCustomGroups: c } = R(
+              return o.push([]), o;
+            let a = e.name.type === "JSXNamespacedName" ? `${e.name.namespace.name}:${e.name.name.name}` : e.name.name, { getGroup: i, defineGroup: n, setCustomGroups: u } = G(
               s.groups
             );
-            c(s["custom-groups"], a), e.value === null && o("shorthand"), e.loc.start.line !== e.loc.end.line && o("multiline");
-            let y = {
-              size: v(e.range),
+            u(s["custom-groups"], a), e.value === null && n("shorthand"), e.loc.start.line !== e.loc.end.line && n("multiline");
+            let g = {
+              size: k(e.range),
               group: i(),
               node: e,
               name: a
             };
-            return n.at(-1).push(y), n;
+            return o.at(-1).push(g), o;
           },
           [[]]
         );
-        for (let n of u)
-          P(n, (e, a) => {
-            let i = x(s.groups, e), o = x(s.groups, a);
-            (i > o || i === o && k(O(e, a, s))) && r.report({
+        for (let o of c)
+          P(o, (e, a) => {
+            let i = x(s.groups, e), n = x(s.groups, a);
+            (i > n || i === n && N(I(e, a, s))) && t.report({
               messageId: "unexpectedJSXPropsOrder",
               data: {
                 left: e.name,
                 right: a.name
               },
               node: a.node,
-              fix: (c) => {
-                let y = {};
-                for (let f of n) {
-                  let g = x(s.groups, f);
-                  g in y ? y[g] = A(
-                    [...y[g], f],
+              fix: (u) => {
+                let g = {};
+                for (let f of o) {
+                  let y = x(s.groups, f);
+                  y in g ? g[y] = A(
+                    [...g[y], f],
                     s
-                  ) : y[g] = [f];
+                  ) : g[y] = [f];
                 }
                 let h = [];
-                for (let f of Object.keys(y).sort())
-                  h.push(...A(y[f], s));
-                return T(c, n, h, t);
+                for (let f of Object.keys(g).sort())
+                  h.push(...A(g[f], s));
+                return L(u, o, h, r);
               }
             });
           });
       }
     }
   }
-}), re = "sort-exports", Ne = j({
+}), re = "sort-exports", Ie = v({
   name: re,
   meta: {
     type: "suggestion",
@@ -1208,41 +1213,41 @@ const Y = "sort-object-types", Ee = j({
       order: d.asc
     }
   ],
-  create: (r) => {
-    let l = C(r.options.at(0), {
+  create: (t) => {
+    let l = C(t.options.at(0), {
       type: p.alphabetical,
       order: d.asc,
       "ignore-case": !1
-    }), s = [[]], t = (u) => {
-      u.type === "ExportAllDeclaration" && u.exported === null ? s.push([]) : s.at(-1).push({
-        size: v(u.range),
-        name: u.source.value,
-        node: u
+    }), s = [[]], r = (c) => {
+      c.type === "ExportAllDeclaration" && c.exported === null ? s.push([]) : s.at(-1).push({
+        size: k(c.range),
+        name: c.source.value,
+        node: c
       });
     };
     return {
-      ExportAllDeclaration: t,
-      ExportNamedDeclaration: (u) => {
-        u.source !== null && t(u);
+      ExportAllDeclaration: r,
+      ExportNamedDeclaration: (c) => {
+        c.source !== null && r(c);
       },
       "Program:exit": () => {
-        let u = r.getSourceCode();
-        for (let n of s)
-          P(n, (e, a) => {
-            k(O(e, a, l)) && r.report({
+        let c = t.getSourceCode();
+        for (let o of s)
+          P(o, (e, a) => {
+            N(I(e, a, l)) && t.report({
               messageId: "unexpectedExportsOrder",
               data: {
                 left: e.name,
                 right: a.name
               },
               node: a.node,
-              fix: (i) => T(i, n, A(n, l), u)
+              fix: (i) => L(i, o, A(o, l), c)
             });
           });
       }
     };
   }
-}), se = "sort-imports", Oe = j({
+}), se = "sort-imports", je = v({
   name: se,
   meta: {
     type: "suggestion",
@@ -1350,8 +1355,8 @@ const Y = "sort-object-types", Ee = j({
       order: d.asc
     }
   ],
-  create: (r) => {
-    let l = C(r.options.at(0), {
+  create: (t) => {
+    let l = C(t.options.at(0), {
       "newlines-between": "always",
       "custom-groups": { type: {}, value: {} },
       "internal-pattern": ["~/**"],
@@ -1360,17 +1365,17 @@ const Y = "sort-object-types", Ee = j({
       "ignore-case": !1,
       groups: []
     }), s = !1;
-    for (let o of l.groups)
-      if (Array.isArray(o))
-        for (let c of o)
-          c === "unknown" && (s = !0);
+    for (let n of l.groups)
+      if (Array.isArray(n))
+        for (let u of n)
+          u === "unknown" && (s = !0);
       else
-        o === "unknown" && (s = !0);
+        n === "unknown" && (s = !0);
     s || (l.groups = [...l.groups, "unknown"]);
-    let t = r.getSourceCode(), u = [], n = (o) => o.type === "ImportDeclaration" && o.specifiers.length === 0, e = (o) => {
-      let c = (S) => [".less", ".scss", ".sass", ".styl", ".pcss", ".css", ".sss"].some(
-        (L) => S.endsWith(L)
-      ), y = (S) => [
+    let r = t.getSourceCode(), c = [], o = (n) => n.type === "ImportDeclaration" && n.specifiers.length === 0, e = (n) => {
+      let u = (S) => [".less", ".scss", ".sass", ".styl", ".pcss", ".css", ".sss"].some(
+        (T) => S.endsWith(T)
+      ), g = (S) => [
         "./index.d.js",
         "./index.d.ts",
         "./index.js",
@@ -1378,12 +1383,12 @@ const Y = "sort-object-types", Ee = j({
         "./index",
         "./",
         "."
-      ].includes(S), h = (S) => S.indexOf("..") === 0, f = (S) => S.indexOf("./") === 0, { getGroup: g, defineGroup: m, setCustomGroups: w } = R(l.groups), E = (S) => l["internal-pattern"].length && l["internal-pattern"].some(
-        (L) => D(S.source.value, L, {
+      ].includes(S), h = (S) => S.indexOf("..") === 0, f = (S) => S.indexOf("./") === 0, { getGroup: y, defineGroup: m, setCustomGroups: w } = G(l.groups), E = (S) => l["internal-pattern"].length && l["internal-pattern"].some(
+        (T) => z(S.source.value, T, {
           nocomment: !0
         })
       ), b = (S) => {
-        let L = [
+        let T = [
           "bun",
           "bun:ffi",
           "bun:jsc",
@@ -1394,21 +1399,23 @@ const Y = "sort-object-types", Ee = j({
           "undici",
           "ws"
         ];
-        return de.includes(
+        return fe.includes(
           S.startsWith("node:") ? S.split("node:")[1] : S
-        ) || L.includes(S);
-      }, N = (S) => !(S.startsWith(".") || S.startsWith("/"));
-      return o.importKind === "type" && (o.type === "ImportDeclaration" && (w(l["custom-groups"].type, o.source.value), y(o.source.value) && m("index-type"), f(o.source.value) && m("sibling-type"), h(o.source.value) && m("parent-type"), E(o) && m("internal-type"), b(o.source.value) && m("builtin-type"), N(o.source.value) && m("external-type")), m("type")), o.type === "ImportDeclaration" && (w(l["custom-groups"].value, o.source.value), n(o) && m("side-effect"), c(o.source.value) && m("style"), y(o.source.value) && m("index"), f(o.source.value) && m("sibling"), h(o.source.value) && m("parent"), E(o) && m("internal"), b(o.source.value) && m("builtin"), N(o.source.value) && m("external")), g();
-    }, a = (o) => o.specifiers.length > 1, i = (o) => {
-      let c;
-      o.type === "ImportDeclaration" ? c = o.source.value : o.moduleReference.type === "TSExternalModuleReference" && o.moduleReference.expression.type === "Literal" ? c = `${o.moduleReference.expression.value}` : c = t.text.slice(...o.moduleReference.range), u.push({
-        size: v(o.range),
-        group: e(o),
-        name: c,
-        node: o,
+        ) || T.includes(S);
+      }, O = (S) => !(S.startsWith(".") || S.startsWith("/"));
+      return n.importKind === "type" && (n.type === "ImportDeclaration" && (w(l["custom-groups"].type, n.source.value), g(n.source.value) && m("index-type"), f(n.source.value) && m("sibling-type"), h(n.source.value) && m("parent-type"), E(n) && m("internal-type"), b(n.source.value) && m("builtin-type"), O(n.source.value) && m("external-type")), m("type")), n.type === "ImportDeclaration" && (w(l["custom-groups"].value, n.source.value), o(n) && m("side-effect"), u(n.source.value) && m("style"), g(n.source.value) && m("index"), f(n.source.value) && m("sibling"), h(n.source.value) && m("parent"), E(n) && m("internal"), b(n.source.value) && m("builtin"), O(n.source.value) && m("external")), y();
+    }, a = (n) => n.specifiers.length > 1, i = (n) => {
+      let u;
+      n.type === "ImportDeclaration" ? u = n.source.value : n.moduleReference.type === "TSExternalModuleReference" && n.moduleReference.expression.type === "Literal" ? u = `${n.moduleReference.expression.value}` : u = r.text.slice(...n.moduleReference.range), c.push({
+        sortRule: "sort-import",
+        text: r.getText(n),
+        size: k(n.range),
+        group: e(n),
+        name: u,
+        node: n,
         ...l.type === p["line-length"] && l["max-line-length"] && {
           hasMultipleImportDeclarations: a(
-            o
+            n
           )
         }
       });
@@ -1418,62 +1425,62 @@ const Y = "sort-object-types", Ee = j({
       ImportDeclaration: i,
       "Program:exit": () => {
         var h;
-        let o = (f, g) => !!t.getTokensBetween(
+        let n = (f, y) => !!r.getTokensBetween(
           f.node,
-          J(g.node, t) || g.node,
+          J(y.node, r) || y.node,
           {
             includeComments: !0
           }
-        ).length, c = (f, g) => {
+        ).length, u = (f, y) => {
           let m = [], w = {};
-          for (let b of g) {
-            let N = x(l.groups, b);
-            N in w ? w[N] = A(
-              [...w[N], b],
+          for (let b of y) {
+            let O = x(l.groups, b);
+            O in w ? w[O] = A(
+              [...w[O], b],
               l
-            ) : w[N] = [b];
+            ) : w[O] = [b];
           }
           let E = Object.keys(w).sort().reduce(
-            (b, N) => [
+            (b, O) => [
               ...b,
-              ...w[N]
+              ...w[O]
             ],
             []
           );
-          for (let b = 0, N = E.length; b < N; b++) {
+          for (let b = 0, O = E.length; b < O; b++) {
             let S = E.at(b);
             if (m.push(
               f.replaceTextRange(
-                M(g.at(b).node, t),
-                t.text.slice(...M(S.node, t))
+                M(y.at(b).node, r),
+                r.text.slice(...M(S.node, r))
               )
             ), l["newlines-between"] !== "ignore") {
-              let L = E.at(b + 1);
-              if (L) {
-                let G = B(
-                  t,
-                  g.at(b),
-                  g.at(b + 1)
+              let T = E.at(b + 1);
+              if (T) {
+                let R = B(
+                  r,
+                  y.at(b),
+                  y.at(b + 1)
                 );
-                (l["newlines-between"] === "always" && x(l.groups, S) === x(l.groups, L) && G !== 0 || l["newlines-between"] === "never" && G > 0) && m.push(
+                (l["newlines-between"] === "always" && x(l.groups, S) === x(l.groups, T) && R !== 0 || l["newlines-between"] === "never" && R > 0) && m.push(
                   f.removeRange([
-                    M(g.at(b).node, t).at(1),
-                    M(g.at(b + 1).node, t).at(0) - 1
+                    M(y.at(b).node, r).at(1),
+                    M(y.at(b + 1).node, r).at(0) - 1
                   ])
-                ), l["newlines-between"] === "always" && x(l.groups, S) !== x(l.groups, L) && G > 1 && m.push(
+                ), l["newlines-between"] === "always" && x(l.groups, S) !== x(l.groups, T) && R > 1 && m.push(
                   f.replaceTextRange(
                     [
-                      M(g.at(b).node, t).at(1),
-                      M(g.at(b + 1).node, t).at(
+                      M(y.at(b).node, r).at(1),
+                      M(y.at(b + 1).node, r).at(
                         0
                       ) - 1
                     ],
                     `
 `
                   )
-                ), l["newlines-between"] === "always" && x(l.groups, S) !== x(l.groups, L) && G === 0 && m.push(
+                ), l["newlines-between"] === "always" && x(l.groups, S) !== x(l.groups, T) && R === 0 && m.push(
                   f.insertTextAfterRange(
-                    M(g.at(b).node, t),
+                    M(y.at(b).node, r),
                     `
 `
                   )
@@ -1482,52 +1489,52 @@ const Y = "sort-object-types", Ee = j({
             }
           }
           return m;
-        }, y = [[]];
-        for (let f of u) {
-          let g = (h = y.at(-1)) == null ? void 0 : h.at(-1);
-          g && o(g, f) ? y.push([f]) : y.at(-1).push(f);
+        }, g = [[]];
+        for (let f of c) {
+          let y = (h = g.at(-1)) == null ? void 0 : h.at(-1);
+          y && n(y, f) ? g.push([f]) : g.at(-1).push(f);
         }
-        for (let f of y)
-          P(f, (g, m) => {
-            let w = x(l.groups, g), E = x(l.groups, m), b = B(t, g, m);
-            !(n(g.node) && n(m.node)) && !o(g, m) && (w > E || w === E && k(O(g, m, l))) && r.report({
+        for (let f of g)
+          P(f, (y, m) => {
+            let w = x(l.groups, y), E = x(l.groups, m), b = B(r, y, m);
+            !(o(y.node) && o(m.node)) && !n(y, m) && (w > E || w === E && N(I(y, m, l))) && t.report({
               messageId: "unexpectedImportsOrder",
               data: {
-                left: g.name,
+                left: y.name,
                 right: m.name
               },
               node: m.node,
-              fix: (N) => c(N, f)
-            }), l["newlines-between"] === "never" && b > 0 && r.report({
+              fix: (O) => u(O, f)
+            }), l["newlines-between"] === "never" && b > 0 && t.report({
               messageId: "extraSpacingBetweenImports",
               data: {
-                left: g.name,
+                left: y.name,
                 right: m.name
               },
               node: m.node,
-              fix: (N) => c(N, f)
-            }), l["newlines-between"] === "always" && (w < E && b === 0 ? r.report({
+              fix: (O) => u(O, f)
+            }), l["newlines-between"] === "always" && (w < E && b === 0 ? t.report({
               messageId: "missedSpacingBetweenImports",
               data: {
-                left: g.name,
+                left: y.name,
                 right: m.name
               },
               node: m.node,
-              fix: (N) => c(N, f)
-            }) : (b > 1 || w === E && b > 0) && r.report({
+              fix: (O) => u(O, f)
+            }) : (b > 1 || w === E && b > 0) && t.report({
               messageId: "extraSpacingBetweenImports",
               data: {
-                left: g.name,
+                left: y.name,
                 right: m.name
               },
               node: m.node,
-              fix: (N) => c(N, f)
+              fix: (O) => u(O, f)
             }));
           });
       }
     };
   }
-}), ae = "sort-objects", Ie = j({
+}), ae = "sort-objects", ve = v({
   name: ae,
   meta: {
     type: "suggestion",
@@ -1589,10 +1596,10 @@ const Y = "sort-object-types", Ee = j({
       order: d.asc
     }
   ],
-  create: (r) => {
+  create: (t) => {
     let l = (s) => {
       if (s.properties.length > 1) {
-        let t = C(r.options.at(0), {
+        let r = C(t.options.at(0), {
           "partition-by-new-line": !1,
           "partition-by-comment": !1,
           type: p.alphabetical,
@@ -1601,96 +1608,96 @@ const Y = "sort-object-types", Ee = j({
           order: d.asc,
           "custom-groups": {},
           groups: []
-        }), u = (i) => i.type === "Identifier" && i.name === "styled", n = (i) => i !== void 0 && i.type === "CallExpression" && (i.callee.type === "MemberExpression" && u(i.callee.object) || i.callee.type === "CallExpression" && u(i.callee.callee));
-        if (!t["styled-components"] && (n(s.parent) || s.parent.type === "ArrowFunctionExpression" && n(s.parent.parent)))
+        }), c = (i) => i.type === "Identifier" && i.name === "styled", o = (i) => i !== void 0 && i.type === "CallExpression" && (i.callee.type === "MemberExpression" && c(i.callee.object) || i.callee.type === "CallExpression" && c(i.callee.callee));
+        if (!r["styled-components"] && (o(s.parent) || s.parent.type === "ArrowFunctionExpression" && o(s.parent.parent)))
           return;
-        let e = r.getSourceCode(), a = (i) => i.reduce(
-          (o, c) => {
+        let e = t.getSourceCode(), a = (i) => i.reduce(
+          (n, u) => {
             var S;
-            if (c.type === "SpreadElement" || c.type === "RestElement")
-              return o.push([]), o;
-            let y = J(c, e), h = (S = o.at(-1)) == null ? void 0 : S.at(-1);
-            t["partition-by-comment"] && y && pe(
-              t["partition-by-comment"],
-              y.value
-            ) && o.push([]);
-            let f, g = "ignore", m = [], { getGroup: w, setCustomGroups: E } = R(t.groups);
-            c.key.type === "Identifier" ? { name: f } = c.key : c.key.type === "Literal" ? f = `${c.key.value}` : f = e.text.slice(...c.key.range);
+            if (u.type === "SpreadElement" || u.type === "RestElement")
+              return n.push([]), n;
+            let g = J(u, e), h = (S = n.at(-1)) == null ? void 0 : S.at(-1);
+            r["partition-by-comment"] && g && ue(
+              r["partition-by-comment"],
+              g.value
+            ) && n.push([]);
+            let f, y = "ignore", m = [], { getGroup: w, setCustomGroups: E } = G(r.groups);
+            u.key.type === "Identifier" ? { name: f } = u.key : u.key.type === "Literal" ? f = `${u.key.value}` : f = e.text.slice(...u.key.range);
             let b = {
-              size: v(c.range),
-              node: c,
+              size: k(u.range),
+              node: u,
               name: f
             };
-            t["partition-by-new-line"] && h && B(e, h, b) && o.push([]), c.value.type === "AssignmentPattern" && ((G) => {
-              G.right.type === "Identifier" && m.push(G.right.name);
+            r["partition-by-new-line"] && h && B(e, h, b) && n.push([]), u.value.type === "AssignmentPattern" && ((R) => {
+              R.right.type === "Identifier" && m.push(R.right.name);
               let ie = ($) => {
-                let U = [];
+                let D = [];
                 switch ($.type) {
                   case "ArrowFunctionExpression":
-                    U.push($.body);
+                    D.push($.body);
                     break;
                   case "ConditionalExpression":
-                    U.push($.consequent, $.alternate);
+                    D.push($.consequent, $.alternate);
                     break;
                   case "LogicalExpression":
                   case "BinaryExpression":
-                    U.push($.left, $.right);
+                    D.push($.left, $.right);
                     break;
                   case "CallExpression":
-                    U.push(...$.arguments);
+                    D.push(...$.arguments);
                     break;
                 }
-                U.forEach((z) => {
-                  z.type === "Identifier" && m.push(z.name), (z.type === "BinaryExpression" || z.type === "ConditionalExpression") && ie(z);
+                D.forEach((U) => {
+                  U.type === "Identifier" && m.push(U.name), (U.type === "BinaryExpression" || U.type === "ConditionalExpression") && ie(U);
                 });
               };
-              switch (G.right.type) {
+              switch (R.right.type) {
                 case "ArrowFunctionExpression":
                 case "ConditionalExpression":
                 case "LogicalExpression":
                 case "BinaryExpression":
                 case "CallExpression":
-                  ie(G.right);
+                  ie(R.right);
                   break;
               }
-            })(c.value), E(t["custom-groups"], f);
-            let N = {
+            })(u.value), E(r["custom-groups"], f);
+            let O = {
               ...b,
               group: w(),
               dependencies: m,
-              position: g
+              position: y
             };
-            return o.at(-1).push(N), o;
+            return n.at(-1).push(O), n;
           },
           [[]]
         );
         for (let i of a(s.properties))
-          P(i, (o, c) => {
-            let y = x(t.groups, o), h = x(t.groups, c);
-            if (y > h || y === h && k(O(o, c, t))) {
-              let f = (g) => {
+          P(i, (n, u) => {
+            let g = x(r.groups, n), h = x(r.groups, u);
+            if (g > h || g === h && N(I(n, u, r))) {
+              let f = (y) => {
                 let m = {};
                 for (let E of i) {
-                  let b = x(t.groups, E);
+                  let b = x(r.groups, E);
                   b in m ? m[b] = A(
                     [...m[b], E],
-                    t
+                    r
                   ) : m[b] = [E];
                 }
                 let w = [];
                 for (let E of Object.keys(m).sort())
-                  w.push(...A(m[E], t));
-                return T(g, i, w, e, {
-                  partitionComment: t["partition-by-comment"]
+                  w.push(...A(m[E], r));
+                return L(y, i, w, e, {
+                  partitionComment: r["partition-by-comment"]
                 });
               };
-              r.report({
+              t.report({
                 messageId: "unexpectedObjectsOrder",
                 data: {
-                  left: I(o.name),
-                  right: I(c.name)
+                  left: j(n.name),
+                  right: j(u.name)
                 },
-                node: c.node,
+                node: u.node,
                 fix: f
               });
             }
@@ -1702,7 +1709,7 @@ const Y = "sort-object-types", Ee = j({
       ObjectPattern: l
     };
   }
-}), ne = "sort-classes", je = j({
+}), ne = "sort-classes", ke = v({
   name: ne,
   meta: {
     type: "suggestion",
@@ -1750,78 +1757,78 @@ const Y = "sort-object-types", Ee = j({
       order: d.asc
     }
   ],
-  create: (r) => ({
+  create: (t) => ({
     ClassBody: (l) => {
       if (l.body.length > 1) {
-        let s = C(r.options.at(0), {
+        let s = C(t.options.at(0), {
           type: p.alphabetical,
           order: d.asc,
           "ignore-case": !1,
           groups: ["property", "constructor", "method", "unknown"]
-        }), t = r.getSourceCode(), u = l.body.map((n) => {
-          var c;
-          let e, { getGroup: a, defineGroup: i } = R(s.groups);
-          n.type === "StaticBlock" ? e = "static" : n.type === "TSIndexSignature" ? e = t.text.slice(
-            n.range.at(0),
-            ((c = n.typeAnnotation) == null ? void 0 : c.range.at(0)) ?? n.range.at(1)
-          ) : n.key.type === "Identifier" ? { name: e } = n.key : e = t.text.slice(...n.key.range);
-          let o = e.startsWith("_") || e.startsWith("#");
-          if (n.type === "MethodDefinition") {
-            n.kind === "constructor" && i("constructor");
-            let y = n.accessibility === "private" || o, h = n.static;
-            y && h && i("static-private-method"), y && i("private-method"), h && i("static-method"), n.kind === "get" && i("get-method"), n.kind === "set" && i("set-method"), i("method");
+        }), r = t.getSourceCode(), c = l.body.map((o) => {
+          var u;
+          let e, { getGroup: a, defineGroup: i } = G(s.groups);
+          o.type === "StaticBlock" ? e = "static" : o.type === "TSIndexSignature" ? e = r.text.slice(
+            o.range.at(0),
+            ((u = o.typeAnnotation) == null ? void 0 : u.range.at(0)) ?? o.range.at(1)
+          ) : o.key.type === "Identifier" ? { name: e } = o.key : e = r.text.slice(...o.key.range);
+          let n = e.startsWith("_") || e.startsWith("#");
+          if (o.type === "MethodDefinition") {
+            o.kind === "constructor" && i("constructor");
+            let g = o.accessibility === "private" || n, h = o.static;
+            g && h && i("static-private-method"), g && i("private-method"), h && i("static-method"), o.kind === "get" && i("get-method"), o.kind === "set" && i("set-method"), i("method");
           } else
-            n.type === "TSIndexSignature" ? i("index-signature") : n.type === "PropertyDefinition" && ((n.accessibility === "private" || o) && i("private-property"), n.static && i("static-property"), i("property"));
+            o.type === "TSIndexSignature" ? i("index-signature") : o.type === "PropertyDefinition" && ((o.accessibility === "private" || n) && i("private-property"), o.static && i("static-property"), i("property"));
           return {
-            size: v(n.range),
+            size: k(o.range),
             group: a(),
-            node: n,
+            node: o,
             name: e
           };
         });
-        P(u, (n, e) => {
-          let a = x(s.groups, n), i = x(s.groups, e);
-          n.name !== e.name && (a > i || a === i && k(O(n, e, s))) && r.report({
+        P(c, (o, e) => {
+          let a = x(s.groups, o), i = x(s.groups, e);
+          o.name !== e.name && (a > i || a === i && N(I(o, e, s))) && t.report({
             messageId: "unexpectedClassesOrder",
             data: {
-              left: I(n.name),
-              right: I(e.name)
+              left: j(o.name),
+              right: j(e.name)
             },
             node: e.node,
-            fix: (o) => {
-              let c = [], y = u.reduce(
-                (f, g) => {
-                  let m = x(s.groups, g);
+            fix: (n) => {
+              let u = [], g = c.reduce(
+                (f, y) => {
+                  let m = x(s.groups, y);
                   return m in f ? f[m] = A(
-                    [...f[m], g],
+                    [...f[m], y],
                     s
-                  ) : f[m] = [g], f;
+                  ) : f[m] = [y], f;
                 },
                 {}
-              ), h = Object.keys(y).sort().reduce(
-                (f, g) => [
+              ), h = Object.keys(g).sort().reduce(
+                (f, y) => [
                   ...f,
-                  ...y[g]
+                  ...g[y]
                 ],
                 []
               );
-              for (let f = 0, g = h.length; f < g; f++)
-                c.push(
-                  o.replaceTextRange(
-                    M(u.at(f).node, t),
-                    t.text.slice(
-                      ...M(h.at(f).node, t)
+              for (let f = 0, y = h.length; f < y; f++)
+                u.push(
+                  n.replaceTextRange(
+                    M(c.at(f).node, r),
+                    r.text.slice(
+                      ...M(h.at(f).node, r)
                     )
                   )
                 );
-              return c;
+              return u;
             }
           });
         });
       }
     }
   })
-}), oe = "sort-enums", ve = j({
+}), oe = "sort-enums", Ne = v({
   name: oe,
   meta: {
     type: "suggestion",
@@ -1865,33 +1872,33 @@ const Y = "sort-object-types", Ee = j({
       order: d.asc
     }
   ],
-  create: (r) => ({
+  create: (t) => ({
     TSEnumDeclaration: (l) => {
       if (l.members.length > 1 && l.members.every(({ initializer: s }) => s)) {
-        let s = C(r.options.at(0), {
+        let s = C(t.options.at(0), {
           type: p.alphabetical,
           order: d.asc,
           "ignore-case": !1
-        }), t = r.getSourceCode(), u = l.members.map((n) => ({
-          name: n.id.type === "Literal" ? `${n.id.value}` : `${t.text.slice(...n.id.range)}`,
-          size: v(n.range),
-          node: n
+        }), r = t.getSourceCode(), c = l.members.map((o) => ({
+          name: o.id.type === "Literal" ? `${o.id.value}` : `${r.text.slice(...o.id.range)}`,
+          size: k(o.range),
+          node: o
         }));
-        P(u, (n, e) => {
-          k(O(n, e, s)) && r.report({
+        P(c, (o, e) => {
+          N(I(o, e, s)) && t.report({
             messageId: "unexpectedEnumsOrder",
             data: {
-              left: I(n.name),
-              right: I(e.name)
+              left: j(o.name),
+              right: j(e.name)
             },
             node: e.node,
-            fix: (a) => T(a, u, A(u, s), t)
+            fix: (a) => L(a, c, A(c, s), r)
           });
         });
       }
     }
   })
-}), le = "sort-maps", ke = j({
+}), le = "sort-maps", Ce = v({
   name: le,
   meta: {
     type: "suggestion",
@@ -1935,42 +1942,42 @@ const Y = "sort-object-types", Ee = j({
       order: d.asc
     }
   ],
-  create: (r) => ({
+  create: (t) => ({
     NewExpression: (l) => {
       if (l.callee.type === "Identifier" && l.callee.name === "Map" && l.arguments.length && l.arguments[0].type === "ArrayExpression") {
         let [{ elements: s }] = l.arguments;
         if (s.length > 1) {
-          let t = C(r.options.at(0), {
+          let r = C(t.options.at(0), {
             type: p.alphabetical,
             "ignore-case": !1,
             order: d.asc
-          }), u = r.getSourceCode(), n = s.reduce(
+          }), c = t.getSourceCode(), o = s.reduce(
             (e, a) => (a === null || a.type === "SpreadElement" ? e.push([]) : e.at(-1).push(a), e),
             [[]]
           );
-          for (let e of n) {
+          for (let e of o) {
             let a = e.map((i) => {
-              let o;
+              let n;
               if (i.type === "ArrayExpression") {
-                let [c] = i.elements;
-                c ? c.type === "Literal" ? o = c.raw : o = u.text.slice(...c.range) : o = `${c}`;
+                let [u] = i.elements;
+                u ? u.type === "Literal" ? n = u.raw : n = c.text.slice(...u.range) : n = `${u}`;
               } else
-                o = u.text.slice(...i.range);
+                n = c.text.slice(...i.range);
               return {
-                size: v(i.range),
+                size: k(i.range),
                 node: i,
-                name: o
+                name: n
               };
             });
-            P(a, (i, o) => {
-              k(O(i, o, t)) && r.report({
+            P(a, (i, n) => {
+              N(I(i, n, r)) && t.report({
                 messageId: "unexpectedMapElementsOrder",
                 data: {
-                  left: I(i.name),
-                  right: I(o.name)
+                  left: j(i.name),
+                  right: j(n.name)
                 },
-                node: o.node,
-                fix: (c) => T(c, a, A(a, t), u)
+                node: n.node,
+                fix: (u) => L(u, a, A(a, r), c)
               });
             });
           }
@@ -1978,8 +1985,8 @@ const Y = "sort-object-types", Ee = j({
       }
     }
   })
-}), Ce = "eslint-plugin-perfectionist";
-let V = (r) => {
+}), Pe = "eslint-plugin-perfectionist";
+let V = (t) => {
   let l = {
     [se]: [
       "error",
@@ -2046,32 +2053,32 @@ let V = (r) => {
   };
   return {
     rules: Object.fromEntries(
-      Object.entries(l).map(([s, [t, u = {}]]) => [
+      Object.entries(l).map(([s, [r, c = {}]]) => [
         `perfectionist/${s}`,
-        [t, Object.assign(u, r)]
+        [r, Object.assign(c, t)]
       ])
     ),
     plugins: ["perfectionist"]
   };
 };
-const Re = {
+const $e = {
   rules: {
-    [K]: me,
-    [q]: ye,
-    [ne]: je,
-    [oe]: ve,
-    [re]: Ne,
-    [se]: Oe,
-    [ee]: we,
-    [te]: Ae,
-    [le]: ke,
-    [H]: be,
-    [Q]: xe,
-    [Y]: Ee,
-    [ae]: Ie,
-    [X]: ge,
-    [Z]: Se,
-    [F]: he
+    [K]: he,
+    [q]: me,
+    [ne]: ke,
+    [oe]: Ne,
+    [re]: Ie,
+    [se]: je,
+    [ee]: Ae,
+    [te]: Oe,
+    [le]: Ce,
+    [H]: xe,
+    [Q]: Ee,
+    [Y]: Se,
+    [ae]: ve,
+    [X]: ye,
+    [Z]: we,
+    [F]: be
   },
   configs: {
     "recommended-alphabetical": V({
@@ -2089,8 +2096,8 @@ const Re = {
       order: d.desc
     })
   },
-  name: Ce
+  name: Pe
 };
 export {
-  Re as default
+  $e as default
 };